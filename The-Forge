local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")
local HttpService = game:GetService("HttpService")
local UserInputService = game:GetService("UserInputService")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local player = Players.LocalPlayer
local LocalPlayer = Players.LocalPlayer or Players.PlayerAdded:Wait()
local Shared = ReplicatedStorage:WaitForChild("Shared")
local Knit = require(Shared:WaitForChild("Packages").Knit)
local Utils = require(Shared:WaitForChild("Utils"))
local Ore = require(Shared:WaitForChild("Data"):WaitForChild("Ore"))
local UIS = game:GetService("UserInputService")
local RS = game:GetService("RunService")
local CoreGui = game:GetService("CoreGui")
-- Keep your existing RS = RunService
local RS = game:GetService("RunService")

-- Add this for remotes only
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RaceRerollRemote = ReplicatedStorage.Shared.Packages.Knit.Services.RaceService.RF.Reroll

local mt = getrawmetatable(game)
local oldNamecall = mt.__namecall
setreadonly(mt, false)

mt.__namecall = newcclosure(function(self, ...)
    local method = getnamecallmethod()
    
    -- BLOCK ALL KICKS (ONLY)
    if method == "Kick" or 
       method == "FireServer" and (tostring(self):lower():find("kick") or 
                                  tostring(self):lower():find("ban")) then
        return -- SILENT BLOCK
    end
    
    return oldNamecall(self, ...)
end)

setreadonly(mt, true)

local function getCharacter()
	return LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
end

local function getHumanoidRootPart()
	local char = getCharacter()
	return char:WaitForChild("HumanoidRootPart")
end

local function getHumanoid()
	local char = getCharacter()
	return char:FindFirstChildOfClass("Humanoid") or char:WaitForChild("Humanoid")
end

local Rayfield = loadstring(game:HttpGet("https://sirius.menu/rayfield"))()

local Window = Rayfield:CreateWindow({
	Name = "PunkX Forge Auto Farm",
	LoadingTitle = "PunkX Forge Automation",
	LoadingSubtitle = "By punkX team",
	ShowText = "PunkX Forge",
	ToggleUIKeybind = "K",
    Discord = {
      Enabled = true,
      Invite = "wN85KUq6nD",
      RememberJoins = true 
    },
	ConfigurationSaving = {
		Enabled = true,
		FolderName = "punkX-forge",
		FileName = "punkX-forge-config"
	}
})

local MainFarmTab = Window:CreateTab("Main Farm", 4483362458)

local DESYNC_FLAGS = {
{"GameNetPVHeaderRotationalVelocityZeroCutoffExponent", "-5000"},
    {"LargeReplicatorWrite5", "True"},
    {"LargeReplicatorEnabled9", "True"},
    {"AngularVelociryLimit", "360"},
    {"TimestepArbiterVelocityCriteriaThresholdTwoDt", "2147483646"},
    {"S2PhysicsSenderRate", "500"},
    {"DisableDPIScale", "True"},
    {"MaxDataPacketPerSend", "500"},
    {"PhysicsSenderMaxBandwidthBps", "5000"},
    {"SimOwnedNOUCountThresholdMillionth", "2147483647"},
    {"MaxMissedWorldStepsRemembered", "-2147483648"},
    {"PlayerHumanoidPropertyUpdateRestrict", "False"},
    {"SimDefaultHumanoidTimestepMultiplier", "50"},
    {"StreamJobNOUVolumeLengthCap", "2147483647"},
    {"DebugSendDistInSteps", "-2147483648"},
    {"LargeReplicatorRead5", "True"},
    {"GameNetDontSendRedundantNumTimes", "1"},
    {"CheckPVCachedRotVelThresholdPercent", "10"},
    {"CheckPVLinearVelocityIntegrateVsDeltaPositionThresholdPercent", "1"},
    {"NextGenReplicatorEnabledWrite4", "True"},
    {"FFlagNextGenReplicatorEnabledWrite4", "True"},
    {"TimestepArbiterHumanoidLinearVelThreshold", "1"},
    {"LargeReplicatorSerializeRead3", "True"},
    {"ReplicationFocusNouExtentsSizeCutoffForPauseStuds", "2147483647"},
    {"WorldStepMax", "30"},
    {"CheckPVDifferencesForInterpolationMinRotVelThresholdRadsPerSecHundredth", "1"},
    {"GameNetDontSendRedundantDeltaPositionMillionth", "1"},
    {"InterpolationFrameVelocityThresholdMillionth", "5"},
    {"StreamJobNOUVolumeCap", "2147483647"},
    {"InterpolationFrameRotVelocityThresholdMillionth", "5"},
    {"CheckPVDifferencesForInterpolationMinVelThresholdStudsPerSecHundredth", "1"},
    {"InterpolationFramePositionThresholdMillionth", "5"},
    {"TimestepArbiterHumanoidTurningVelThreshold", "1"},
    {"GameNetPVHeaderLinearVelocityZeroCutoffExponent", "-5000"},
    {"CheckPVCachedVelThresholdPercent", "10"},
    {"TimestepArbiterOmegaThou", "1073741823"},
    {"MaxAcceptableUpdateDelay", "999999"},  -- UPDATED
    {"LargeReplicatorSerializeWrite4", "True"},
    {"DFFlagDebugEnableInterpThrottle", "True"}, 
    {"FLogNetwork", "7"},
    {"DFFlagUseCharacterControllerForLocalSimulation", "True"},
    {"DFIntMaxTimestepMultiplierSimulation", "2147483647"},
    {"DFIntSimExplicitlyCappedTimestepMultiplier", "2147483646"},
    {"DFIntGameNetPVHeaderTranslationZeroCutoffExponent", "-2147483647"},
    {"DFIntClientPhysicsMaxSendRate", "500"},
    {"DFIntReplicationMaxPacketSize", "500"},
    {"DFIntClientReplicationMaxReceiveRate", "1"},  
    {"DFIntNetworkPeerMaxResendPacketCount", "1"},  
    {"DFIntNetworkPeerMaxReceivePacketCount", "1"},
    {"DFIntNetworkPredictiveTickRate", "1"},
    {"DFIntClientSimSeaLevel", "999999"},
    {"DFIntMaxPingForLagCompensation", "999999"},
    {"DFIntKickThresholdPacketLossPercent", "999"},
    {"DFIntKickThresholdHighLatencyMs", "999999"},
    {"DFIntKickThresholdLowLatencyMs", "1"},
    {"DFIntServerTickRate", "1"},
    {"FFlagEnableKickOnHighLatency", "False"},
    {"FFlagEnableKickOnPacketLoss", "False"},
    {"FFlagEnableAfkKick", "False"},
    {"FFlagEnablePositionValidationKick", "False"},
    {"FFlagEnableSpeedHackDetection", "False"},
    {"FFlagEnableFlyHackDetection", "False"},
    {"FFlagEnableNoclipDetection", "False"},
    {"FFlagEnableTeleportDetection", "False"},
    {"DFIntMaxDistancePerTick", "999999"},
    {"DFIntMaxVelocityPerTick", "999999"},
}

local desyncEnabled = false
local originalFlags = {}

-- SAVE ORIGINAL FLAGS
local function saveOriginalFlags()
    for _, flagData in pairs(DESYNC_FLAGS) do
        pcall(function()
            originalFlags[flagData[1]] = getfflag(flagData[1])
        end)
    end
end

-- APPLY FLAGS WITH setflag()
local function setDesyncFlags(enable)
    for _, flagData in pairs(DESYNC_FLAGS) do
        local flagName, flagValue = flagData[1], flagData[2]
        pcall(function()
            if enable then
                setflag(flagName, flagValue)  -- USING setflag()
            else
                if originalFlags[flagName] ~= nil then
                    setflag(flagName, originalFlags[flagName])  -- RESTORE WITH setflag()
                end
            end
        end)
    end
end

local flags = {
    "FFlagDebugDisableNetworkThrottling", "true",
    "FFlagDebugDisableNetworkRateLimiter", "true",
    "FFlagDebugDisableRemoteRateLimiter", "true",
    "FFlagDebugDisableRemoteEventSizeLimiter", "true",
    "FFlagDebugDisablePacketLossSimulation", "true",
    "FFlagDebugDisableNetworkFiltering", "true",
    "FFlagDebugDisableNetworkValidation", "true",
    "FFlagDebugForceNetworkMaxSpeed", "true",
    "FFlagDebugDisableReplicationThrottling", "true",
    "FFlagDebugDisableReplicationLimiter", "true",
    "FFlagDebugForceReplicationImmediate", "true",
    "FFlagDebugDisableReplicationBatching", "true",
    "FFlagDebugForceReplicationNoQueue", "true",
    "FFlagDebugForceReplicationMaxSpeed", "true",
    "FFlagDebugDisableServerRateLimiter", "true",
    "FFlagDebugDisableServerRemoteLimiter", "true",
    "FFlagDebugDisableServerReplicationLimiter", "true",
    "FFlagDebugForceServerImmediateProcess", "true",
    "FFlagDebugDisableServerValidation", "true",
    "FFlagDebugForceServerMaxSpeed", "true",
    "FFlagDebugDisableInputThrottling", "true",
    "FFlagDebugDisableMouseThrottling", "true",
    "FFlagDebugDisableToolActivationLimiter", "true",
    "FFlagDebugForceInputImmediate", "true",
    "FFlagDebugForceInputMaxSpeed", "true",
    "FFlagDebugDisableAnimationValidation", "true",
    "FFlagDebugForceAnimationImmediate", "true",
    "FFlagDebugDisableAnimationRateLimit", "true",
    "FFlagDebugDisableAnimationSyncCheck", "true",
    "FFlagDebugForceAnimationMaxSpeed", "true",
    "FFlagDebugDisableAnimationThrottling", "true",
    "FFlagDebugForceAnimationNoQueue", "true",
    "FFlagDebugAnimationPriorityMax", "true",
    "FFlagDebugSimHighFpsMode", "true",
    "DFIntTaskSchedulerTargetFps", "999999999999999999",
    "DFIntConnectionSendRate", "999999999999999999",
    "DFIntMinimumFrameRate", "999999999999999999",
    "DFIntMaxFrameRate", "999999999999999999",
    "DFIntAnimationMaxSpeed", "999999999999999",
    "FFlagDebugForceAnimationInstant", "true",
    "FFlagDebugForceRemotePriorityMax", "true",
    "FFlagDebugDisableNetworkQueue", "true",
    "FFlagDebugForceImmediateRemote", "true",
    "FFlagDebugDisableServerQueueing", "true"
}

for i = 1, #flags, 2 do
    pcall(function()
        setfflag(flags[i], flags[i + 1])
    end)
end


local fuckActive = false
local connections = {}
local originalStates = {}
local state = {
    char = nil,
    humanoid = nil,
    rootPart = nil,
    animator = nil,
    frameCount = 0
}

local function backupOriginalStates()
    pcall(function()
        if state.humanoid then
            originalStates.platformStand = state.humanoid.PlatformStand
            originalStates.sit = state.humanoid.Sit
            originalStates.jump = state.humanoid.Jump
        end
        if state.rootPart then
            originalStates.anchored = state.rootPart.Anchored
            originalStates.velocity = state.rootPart.Velocity
        end
    end)
end

local function restoreOriginalStates()
    pcall(function()
        if state.humanoid and originalStates.platformStand ~= nil then
            state.humanoid.PlatformStand = originalStates.platformStand
            state.humanoid.Sit = originalStates.sit or false
            state.humanoid.Jump = originalStates.jump or false
        end
        if state.rootPart and originalStates.anchored ~= nil then
            state.rootPart.Anchored = originalStates.anchored
        end
        originalStates = {}
    end)
end

local function safeRefresh()
    pcall(function()
        state.char = LocalPlayer.Character
        if state.char then
            state.rootPart = state.char:FindFirstChild("HumanoidRootPart")
            state.humanoid = state.char:FindFirstChild("Humanoid")
            state.animator = state.humanoid and state.humanoid:FindFirstChild("Animator")
        end
    end)
end

local function perfectMovementControl()
    pcall(function()
        if state.humanoid and state.rootPart then
            if state.humanoid.PlatformStand then
                state.humanoid.PlatformStand = false
            end
            if state.rootPart.Anchored then
                state.rootPart.Anchored = false
            end
        end
    end)
end

local function getForgeRemotes()
    local remotes = {}
    pcall(function()
        local shared = ReplicatedStorage:FindFirstChild("Shared")
        if shared then
            local packages = shared:FindFirstChild("Packages")
            if packages then
                local knit = packages:FindFirstChild("Knit")
                if knit then
                    local services = knit:FindFirstChild("Services")
                    if services then
                        local toolService = services:FindFirstChild("ToolService")
                        if toolService then
                            local rf = toolService:FindFirstChild("RF")
                            local re = toolService:FindFirstChild("RE")
                            if rf and rf:FindFirstChild("ToolActivated") then
                                table.insert(remotes, rf.ToolActivated)
                            end
                            if re and re:FindFirstChild("Mine") then
                                table.insert(remotes, re.Mine)
                            end
                        end
                    end
                end
            end
        end
    end)
    return remotes
end

local function animationFix()
    pcall(function()
        if state.animator then
            for _, track in pairs(state.animator:GetPlayingAnimationTracks()) do
                track:AdjustSpeed(10)
            end
        end
    end)
end

local function remoteSpam()
    local remotes = getForgeRemotes()
    for _, remote in pairs(remotes) do
        pcall(function()
            remote:FireServer()
        end)
    end
end

local function debounceNuke()
    pcall(function()
        if state.char then
            for _, obj in pairs(state.char:GetDescendants()) do
                local name = string.lower(obj.Name)
                if obj:IsA("NumberValue") and (
                    name:find("cooldown") or name:find("timer") or name:find("debounce") or 
                    name:find("hit") or name:find("swing") or name:find("damage")
                ) then
                    obj.Value = 0
                elseif obj:IsA("BoolValue") and (
                    name:find("hit") or name:find("ready") or name:find("active")
                ) then
                    obj.Value = true
                end
            end
        end
    end)
end

local function startFuckMode()
    safeRefresh()
    backupOriginalStates()
    
    connections.movement = RunService.Stepped:Connect(function()
        if fuckActive then
            perfectMovementControl()
        end
    end)
    
    connections.action = RunService.Heartbeat:Connect(function()
        if fuckActive then
            safeRefresh()
            animationFix()
            remoteSpam()
            debounceNuke()
        end
    end)
end

local function stopFuckMode()
    for _, conn in pairs(connections) do
        if conn then 
            pcall(function() conn:Disconnect() end)
        end
    end
    connections = {}
    restoreOriginalStates()
    safeRefresh()
end

local godEnabled = false
local connections = {}
local player = game:GetService("Players").LocalPlayer
local deathPosition = nil
local isRecovering = false
local lockedPosition = nil
local lockEndTime = 0

local function clearConnections()
    for _, conn in pairs(connections) do 
        pcall(function() if conn then conn:Disconnect() end end) 
    end
    connections = {}
end


local function killDeathScreen()
    pcall(function()
        local pg = player.PlayerGui
        for _, gui in pairs(pg:GetChildren()) do
            if gui.Name == "DeathScreen" or gui.Name:lower():find("death") or gui.Name:lower():find("respawn") then
                for _, child in pairs(gui:GetChildren()) do
                    pcall(function() child:Destroy() end)
                end
                gui.Enabled = false
                gui:Destroy()
            end
        end
    end)
end

local function applyGodmode(char)
    clearConnections()
    local humanoid = char:WaitForChild("Humanoid")
    local rootPart = char:WaitForChild("HumanoidRootPart")
    
    
    pcall(function()
        humanoid.Died:Connect(function()
            humanoid.Health = 100
            killDeathScreen()
            deathPosition = rootPart.CFrame
            isRecovering = true
            print(" DEATH CANCELLED - POSITION SAVED!")
        end)
    end)
    
    
    connections[#connections+1] = game:GetService("RunService").Heartbeat:Connect(function()
        if godEnabled and humanoid.Parent then
            pcall(function()
                humanoid.MaxHealth = math.huge
                humanoid.Health = math.huge
            end)
        end
    end)
    
    
    spawn(function()
        while godEnabled and char.Parent do
            pcall(function()
                for _, ff in pairs(char:GetChildren()) do
                    if ff:IsA("ForceField") then ff:Destroy() end
                end
                for i = 1, 12 do
                    local ff = Instance.new("ForceField")
                    ff.Parent = char
                end
            end)
            task.wait(0.08)
        end
    end)
end


local function lockPosition(rootPart, lockCFrame)
    lockedPosition = lockCFrame
    lockEndTime = tick() + 5  
    
    
    connections[#connections+1] = game:GetService("RunService").Heartbeat:Connect(function()
        if tick() < lockEndTime and lockedPosition and rootPart.Parent then
            
            rootPart.CFrame = lockedPosition
            
            
            if tick() % 1 < 0.016 then  
                print(" POSITION LOCKED: " .. math.ceil(lockEndTime - tick()) .. "s remaining")
            end
        else
            lockedPosition = nil
            lockEndTime = 0
        end
    end)
end


player.CharacterAdded:Connect(function(newChar)
    if godEnabled and deathPosition and isRecovering then
        print(" SPAWN TP + POSITION LOCK!")
        
        local root = newChar:WaitForChild("HumanoidRootPart", 3)
        local humanoid = newChar:WaitForChild("Humanoid", 3)
        
        if root and humanoid then
            
            local safeCFrame = deathPosition * CFrame.new(0, 2, 0)
            root.CFrame = safeCFrame
            humanoid.Health = 100
            print("TELEPORTED - POSITION LOCK ACTIVATED!")
            
            
            lockPosition(root, safeCFrame)
            
            
            task.wait(0.1)
            isRecovering = false
            deathPosition = nil
        end
        
        
        task.spawn(function()
            task.wait(0.2)
            applyGodmode(newChar)
            print("GODMODE + POSITION LOCK COMPLETE!")
        end)
    elseif godEnabled then
        task.spawn(function()
            task.wait(0.3)
            applyGodmode(newChar)
        end)
    end
end)


local function toggleGodmode(enable)
    godEnabled = enable
    isRecovering = false
    deathPosition = nil
    lockedPosition = nil
    lockEndTime = 0
    killDeathScreen()
    
    if enable and player.Character then
        applyGodmode(player.Character)
    elseif player.Character then
        clearConnections()
        for _, ff in pairs(player.Character:GetChildren()) do
            if ff:IsA("ForceField") then ff:Destroy() end
        end
    end
end

if getgenv()._RealFly then getgenv()._RealFly.cleanup() end

local plr = Players.LocalPlayer
local flying = false
local velocity
local input = {}
local speed = 70
local mobileGui
local buttons = {}

local directions = {
    W = Vector3.new(0, 0, -1),
    A = Vector3.new(-1, 0, 0),
    S = Vector3.new(0, 0, 1),
    D = Vector3.new(1, 0, 0),
    [","] = Vector3.new(0, -1, 0),
    ["."] = Vector3.new(0, 1, 0)
}

function createMobileControls()
    if not UIS.TouchEnabled then return end
    if mobileGui then mobileGui:Destroy() end
    
    mobileGui = Instance.new("ScreenGui")
    mobileGui.Name = "RealFlyMobile"
    mobileGui.ResetOnSpawn = false
    mobileGui.Parent = CoreGui
    
    local toggleBtn = Instance.new("ImageButton")
    toggleBtn.Name = "FlyToggle"
    toggleBtn.Image = "rbxassetid://70974474105676"
    toggleBtn.Size = UDim2.new(0, 60, 0, 60)
    toggleBtn.Position = UDim2.new(1, -70, 0, 10)
    toggleBtn.BackgroundTransparency = 1
    toggleBtn.Parent = mobileGui
    
    toggleBtn.InputBegan:Connect(function(inputObject)
        if inputObject.UserInputType == Enum.UserInputType.Touch then
            getgenv()._FlyToggle(not flying)
        end
    end)
    
    local function createButton(name, position, text)
        local btn = Instance.new("TextButton")
        btn.Name = name
        btn.Text = text
        btn.Position = position
        btn.Size = UDim2.new(0, 60, 0, 60)
        btn.BackgroundTransparency = 0.7
        btn.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
        btn.TextColor3 = Color3.fromRGB(255, 255, 255)
        btn.TextSize = 20
        btn.Parent = mobileGui
        return btn
    end
    
    buttons.W = createButton("W", UDim2.new(0, 100, 1, -150), "W")
    buttons.A = createButton("A", UDim2.new(0, 30, 1, -90), "A")
    buttons.S = createButton("S", UDim2.new(0, 100, 1, -90), "S")
    buttons.D = createButton("D", UDim2.new(0, 170, 1, -90), "D")
    buttons[","] = createButton("Down", UDim2.new(1, -70, 1, -90), "▼")
    buttons["."] = createButton("Up", UDim2.new(1, -70, 1, -150), "▲")
    
    for k, btn in pairs(buttons) do
        local touchCount = 0
        btn.InputBegan:Connect(function(inputObject)
            if inputObject.UserInputType == Enum.UserInputType.Touch then
                touchCount = touchCount + 1
                input[k] = true
                btn.BackgroundTransparency = 0.5
            end
        end)
        btn.InputEnded:Connect(function(inputObject)
            if inputObject.UserInputType == Enum.UserInputType.Touch then
                touchCount = math.max(0, touchCount - 1)
                if touchCount == 0 then
                    input[k] = false
                    btn.BackgroundTransparency = 0.7
                end
            end
        end)
    end
end

local ib = UIS.InputBegan:Connect(function(key, gpe)
    if gpe then return end
    local k = key.KeyCode.Name
    if k == "X" then
        getgenv()._FlyToggle(not flying)
    elseif directions[k] then
        input[k] = true
    end
end)

local ie = UIS.InputEnded:Connect(function(key)
    local k = key.KeyCode.Name
    if directions[k] then
        input[k] = false
    end
end)

local step = RS.RenderStepped:Connect(function()
    if not flying or not velocity then return end
    local moveVec = Vector3.new(0, 0, 0)
    local camCF = workspace.CurrentCamera.CFrame
    for k, isPressed in pairs(input) do
        if isPressed then
            moveVec = moveVec + camCF:VectorToWorldSpace(directions[k])
        end
    end
    velocity.Velocity = moveVec.Magnitude > 0 and moveVec.Unit * speed or Vector3.new(0, 0, 0)
end)

getgenv()._FlyToggle = function(enabled)
    flying = enabled
    local currentChar = plr.Character
    if not currentChar then return end
    local currentHRP = currentChar:FindFirstChild("HumanoidRootPart")
    
    if enabled then
        if currentHRP then
            velocity = Instance.new("BodyVelocity")
            velocity.MaxForce = Vector3.new(1, 1, 1) * 1000000000
            velocity.P = 10000
            velocity.Velocity = Vector3.new(0, 0, 0)
            velocity.Parent = currentHRP
        end
        if UIS.TouchEnabled then
            createMobileControls()
        end
    else
        if velocity then velocity:Destroy() end
        if mobileGui then mobileGui:Destroy() end
        input = {}
    end
end

getgenv()._FlySpeed = function(newSpeed)
    speed = newSpeed
end

getgenv()._RealFly = {
    cleanup = function()
        getgenv()._FlyToggle(false)
        if ib then ib:Disconnect() end
        if ie then ie:Disconnect() end
        if step then step:Disconnect() end
    end
}

plr.CharacterAdded:Connect(function(newChar)
    if flying and velocity then
        task.wait(1)
        local newHRP = newChar:WaitForChild("HumanoidRootPart")
        velocity.Parent = newHRP
    end
end)

local DesyncSection = MainFarmTab:CreateSection("Desync")

MainFarmTab:CreateToggle({
    Name = "Fly",
    CurrentValue = false,
    Flag = "Forge_Fly",
    Callback = function(value)
        getgenv()._FlyToggle(value)
    end
})

MainFarmTab:CreateSlider({
    Name = "Fly Speed",
    Range = { 16, 85 },
    Increment = 1,
    Suffix = " Speed",
    CurrentValue = 70,
    Flag = "Forge_FlySpeed",
    Callback = function(value)
        getgenv()._FlySpeed(value)
    end
})

MainFarmTab:CreateToggle({
    Name = "tp to dead spot bypass", 
    CurrentValue = false, 
    Flag = "NoDeath_Godmode", 
    Callback = function(v) 
        toggleGodmode(v)
    end
})

player.CharacterAdded:Connect(function(char)
    if godEnabled then
        task.wait(1)
        applyGodmode(char)
    end
end)

MainFarmTab:CreateToggle({
    Name = "Desync",
    CurrentValue = false,
    Flag = "Forge_Desync",
    Callback = function(value)
          desyncEnabled = value
        if value then
            saveOriginalFlags()
            setDesyncFlags(true)
        else
            setDesyncFlags(false)
        end
    end
})


local oreFarm = {
	enabled = false,
	tweenSpeed = 85,
	selectedRockTypes = {},
	selectedOreTypes = {},
	rocksESPEnabled = false,
	pickaxeName = "?",
	pickaxeDamage = 0,
	maxRockTime = 4,
	mineInterval = 0.02,
	scanDistance = 500,
}

local MovementSection = MainFarmTab:CreateSection("Movement Settings")

MainFarmTab:CreateButton({
    Name = "Instant Spin",
    Callback = function()
        RaceRerollRemote:InvokeServer() 
    end
})

MainFarmTab:CreateSlider({
	Name = "Scan Distance",
	Range = { 100, 500 },
	Increment = 100,
	CurrentValue = oreFarm.scanDistance,
	Flag = "Forge_ScanDistance",
	Callback = function(value)
		oreFarm.scanDistance = value
	end,
})

MainFarmTab:CreateSlider({
    Name = "Tween Speed",
    Range = { 30, 85 },
    Increment = 10,
    CurrentValue = 85, 
    Flag = "Forge_TweenSpeed",
    Callback = function(value)
        tweenSpeed = value or 85
    end,
})

local AutoFarmSection = MainFarmTab:CreateSection("Auto Farm Ores")

local PickaxeDebugParagraph 

-- Build dropdown options from ReplicatedStorage.Assets.Rocks (master list)
local function buildRockOptions()
	local assets = ReplicatedStorage:FindFirstChild("Assets")
	local rocksFolder = assets and assets:FindFirstChild("Rocks")
	local options = {}
	if rocksFolder then
		for _, rock in ipairs(rocksFolder:GetChildren()) do
			if rock.Name and rock.Name ~= "" then
				table.insert(options, rock.Name)
			end
		end
	end
	table.sort(options)
	if #options == 0 then
		warn("[Forge] No rock templates found in ReplicatedStorage.Assets.Rocks")
	end
	return options
end

local function buildOreOptions()
	local assets = ReplicatedStorage:FindFirstChild("Assets")
	local oresFolder = assets and assets:FindFirstChild("Ores")
	local options = {}
	if oresFolder then
		for _, ore in ipairs(oresFolder:GetChildren()) do
			if ore.Name and ore.Name ~= "" then
				table.insert(options, ore.Name)
			end
		end
	end
	table.sort(options)
	return options
end

local rockOptions = buildRockOptions()
local oreOptions = buildOreOptions()

if #rockOptions == 0 then
	table.insert(rockOptions, "Boulder")
end

if #oreOptions == 0 then
	table.insert(oreOptions, "Any")
end

oreFarm.selectedRockTypes = { rockOptions[1] }
oreFarm.selectedOreTypes = { oreOptions[1] }

local function listToSet(list)
	local set = {}
	for _, v in ipairs(list) do
		set[tostring(v)] = true
	end
	return set
end

local RockTypeDropdown

local function RefreshRockOptions()
	rockOptions = buildRockOptions()
	if #rockOptions == 0 then
		rockOptions = { "Boulder" }
	end
	if not oreFarm.selectedRockTypes or #oreFarm.selectedRockTypes == 0 then
		oreFarm.selectedRockTypes = { rockOptions[1] }
	end
	if RockTypeDropdown then
		RockTypeDropdown:Set({
			Options = rockOptions,
			CurrentOption = oreFarm.selectedRockTypes,
		})
	end
end

RockTypeDropdown = MainFarmTab:CreateDropdown({
	Name = "Rock Types to Farm",
	Options = rockOptions,
	MultipleOptions = true,
	CurrentOption = oreFarm.selectedRockTypes,
	Flag = "Forge_RockTypes",
	Callback = function(opts)
		if type(opts) == "table" and #opts > 0 then
			oreFarm.selectedRockTypes = opts
		end
	end,
})

MainFarmTab:CreateButton({
	Name = "Refresh Rock Types",
	Callback = function()
		RefreshRockOptions()
	end,
})

MainFarmTab:CreateDropdown({
	Name = "Ore Types to Farm",
	Options = oreOptions,
	MultipleOptions = true,
	CurrentOption = oreFarm.selectedOreTypes,
	Flag = "Forge_OreTypes",
	Callback = function(opts)
		if type(opts) == "table" and #opts > 0 then
			oreFarm.selectedOreTypes = opts
		end
	end,
})

MainFarmTab:CreateSlider({
	Name = "Max Time Per Rock (s)",
	Range = { 1, 20 },
	Increment = 1,
	CurrentValue = oreFarm.maxRockTime,
	Flag = "Forge_MaxRockTime",
	Callback = function(value)
		oreFarm.maxRockTime = value
	end,
})

MainFarmTab:CreateSlider({
	Name = "Mine Interval (s)",
	Range = { 0.02, 0.5 },
	Increment = 0.02,
	CurrentValue = oreFarm.mineInterval,
	Flag = "Forge_MineInterval",
	Callback = function(value)
		oreFarm.mineInterval = value
	end,
})

-- Pickaxe detection based on ReplicatedStorage assets
local pickaxeTemplateNames

local function buildPickaxeTemplateNames()
	local result = {}
	local assets = ReplicatedStorage:FindFirstChild("Assets")
	local equipFolder = assets and assets:FindFirstChild("Equipments")
	local pickaxesFolder = equipFolder and equipFolder:FindFirstChild("Pickaxes")
	if pickaxesFolder then
		for _, tool in ipairs(pickaxesFolder:GetChildren()) do
			local name = tool.Name
			if name and name ~= "" then
				result[string.lower(name)] = true
			end
		end
	end
	return result
end

local function initPickaxeTemplates()
	if not pickaxeTemplateNames then
		pickaxeTemplateNames = buildPickaxeTemplateNames()
	end
end

local function isPickaxe(tool)
	if not (tool and tool:IsA("Tool")) then return false end
	initPickaxeTemplates()
	local name = string.lower(tool.Name or "")
	local itemNameAttr = tool:GetAttribute("ItemName")
	local itemNameLower = itemNameAttr and string.lower(tostring(itemNameAttr)) or ""
	-- Exact template match first
	if pickaxeTemplateNames[name] or (itemNameLower ~= "" and pickaxeTemplateNames[itemNameLower]) then
		return true
	end
	-- Fallback: substring match on "pickaxe" in name or ItemName so we don't miss valid tools
	if name:find("pickaxe", 1, true) or itemNameLower:find("pickaxe", 1, true) then
		return true
	end
	return false
end

local function ensurePickaxeEquipped()
	local char = getCharacter()

	local hum = getHumanoid()
	-- Already equipped
	for _, t in ipairs(char:GetChildren()) do
		if isPickaxe(t) then
			return t
		end
	end
	-- Find in Backpack
	local backpack = LocalPlayer:FindFirstChild("Backpack")
	if not backpack then return nil end

	for _, t in ipairs(backpack:GetChildren()) do
		if isPickaxe(t) then
			pcall(function()
				if hum then
					hum:EquipTool(t)
				else
					t.Parent = char
				end
			end)
			task.wait(0.1)
			return t
		end
	end
	warn("[Forge] No pickaxe found in character or backpack")
	return nil
end

-- Helpers to read equipped pickaxe name & damage from UI
local function updatePickaxeInfoFromGui()
	local char = getCharacter()
	local pickaxeTool = nil
	
	-- Check character for equipped tool with ItemJSON
	for _, tool in ipairs(char:GetChildren()) do
		if tool:IsA("Tool") and tool:GetAttribute("ItemJSON") then
			pickaxeTool = tool
			break
		end
	end
	
	-- Fallback to backpack
	if not pickaxeTool then
		local backpack = LocalPlayer:FindFirstChild("Backpack")
		if backpack then
			for _, tool in ipairs(backpack:GetChildren()) do
				if tool:IsA("Tool") and tool:GetAttribute("ItemJSON") then
					pickaxeTool = tool
					break
				end
			end
		end
	end
	
	if not pickaxeTool then 
		return 
	end

	local itemJson = pickaxeTool:GetAttribute("ItemJSON")
	if type(itemJson) ~= "string" or itemJson == "" then 
		return 
	end

	local decoded
	local ok = pcall(function()
		decoded = HttpService:JSONDecode(itemJson)
	end)
	
	if not ok or type(decoded) ~= "table" then
		return
	end

	local pickName = tostring(decoded.Name or "?")
	oreFarm.pickaxeName = pickName

	-- Try to get damage from GUI
	local pg = LocalPlayer:FindFirstChild("PlayerGui")
	if not pg then return end
	
	local menu = pg:FindFirstChild("Menu")
	if not menu then return end
	
	local frame1 = menu:FindFirstChild("Frame")
	if not frame1 then return end
	
	local frame2 = frame1:FindFirstChild("Frame")
	if not frame2 then return end
	
	local menus = frame2:FindFirstChild("Menus")
	if not menus then return end
	
	local toolsFolder = menus:FindFirstChild("Tools")
	if not toolsFolder then return end
	
	local toolsFrame = toolsFolder:FindFirstChild("Frame")
	if not toolsFrame then return end
	
	local toolGui = toolsFrame:FindFirstChild(pickName)
	if not toolGui then return end
	
	local statsFrame = toolGui:FindFirstChild("Stats")
	if not statsFrame then return end
	
	local dmgLabel = statsFrame:FindFirstChild("DMG")
	if not dmgLabel then return end
	
	if dmgLabel:IsA("TextLabel") then
		local text = tostring(dmgLabel.Text or "")
		local dmg = tonumber(text:match("^(%d+)%s*DMG")) or tonumber(text:match("^(%d+)%D")) or 0
		oreFarm.pickaxeDamage = dmg or 0
	end

	if PickaxeDebugParagraph then
		PickaxeDebugParagraph:Set({
			Title = "Pickaxe Info",
			Content = string.format("Name: %s\nDamage: %s", oreFarm.pickaxeName or "?", tostring(oreFarm.pickaxeDamage or 0)),
		})
	end
end

-- Rock discovery helpers (workspace.Rocks, ignore folder names)
local function getRocksRoot()
	return workspace:FindFirstChild("Rocks")
end

local function getRockHealthValue(rockModel)
	if not rockModel then
		return nil
	end
	local healthAttr = rockModel:GetAttribute("Health")
	if healthAttr == nil then
		local rockChild = rockModel:FindFirstChild("Rock") or rockModel:FindFirstChild("Boulder")
		if rockChild then
			healthAttr = rockChild:GetAttribute("Health")
		end
	end
	if healthAttr == nil then
		for _, child in ipairs(rockModel:GetChildren()) do
			local attr = child:GetAttribute("Health")
			if attr ~= nil then
				healthAttr = attr
				break
			end
		end
	end
	local numeric = tonumber(healthAttr)
	return numeric
end

local function isRockDestroyed(rockModel)
	if not rockModel or not rockModel.Parent then
		return true
	end
	local numeric = getRockHealthValue(rockModel)
	if numeric ~= nil then
		return numeric <= 0
	end
	return false
end

local function collectAllRocks(maxDist, origin)
	local rocksRoot = getRocksRoot()
	local result = {}
	if not rocksRoot then return result end
	
	-- Pre-calculate scan constraints
	local scanDistSq = maxDist and (maxDist * maxDist)
	
	for _, folder in ipairs(rocksRoot:GetChildren()) do
		for _, container in ipairs(folder:GetChildren()) do
			-- 1. Fast existence check
			if not container or not container.Parent then continue end

			-- 2. Find Core Part (Position) - Attempt fastest methods first
			local core = container:IsA("BasePart") and container 
				or container.PrimaryPart 
				or container:FindFirstChild("HumanoidRootPart")
				or container:FindFirstChildWhichIsA("BasePart")
			
			if not core then continue end

			-- 3. DISTANCE CHECK (Early Exit)
			-- Using Squared Distance to avoid square root calculation for slightly better performance
			if scanDistSq and origin then
				local pos = core.Position
				local distSq = (pos.X - origin.X)^2 + (pos.Y - origin.Y)^2 + (pos.Z - origin.Z)^2
				if distSq > scanDistSq then
					continue
				end
			end

			-- 4. Health/Destroyed Check (Potentially expensive attribute lookups)
			if isRockDestroyed(container) then
				continue
			end

			-- 5. Visual/Attribute gathering
			local visual = container:FindFirstChild("Boulder")
			if not visual then
				visual = container:FindFirstChild("Rock")
			end
			if not visual then
				for _, child in ipairs(container:GetChildren()) do
					if child:IsA("Model") or child:IsA("BasePart") then
						visual = child
						break
					end
				end
			end

			if visual then
				local rockTypeName = container:GetAttribute("RockType") or visual:GetAttribute("RockType")
				
				-- If no attribute found, try to extract from visual model name
				if not rockTypeName or rockTypeName == "" then
					rockTypeName = visual.Name
				end
				
				-- If still empty or generic, try looking for ore names inside the rock
				if not rockTypeName or rockTypeName == "" or rockTypeName == "Boulder" or rockTypeName == "Rock" then
					local rockFolder = visual:FindFirstChild("Rock") or visual:FindFirstChild("Boulder")
					if rockFolder then
						for _, inst in ipairs(rockFolder:GetDescendants()) do
							local oreNameAttr = inst:GetAttribute("Ore")
							if oreNameAttr then
								rockTypeName = tostring(oreNameAttr)
								break
							end
						end
					end
				end
				
				-- Final fallback: use container name only if it's not a folder name
				if not rockTypeName or rockTypeName == "" then
					local containerName = container.Name
					-- Skip obvious folder names
					if containerName ~= "Spawn" and containerName ~= "Rocks" and containerName ~= "Rock" and containerName ~= "Boulder" and not containerName:match("^Part") then
						rockTypeName = containerName
					else
						rockTypeName = "Unknown"
					end
				end
				
				local requiredDamage = tonumber(container:GetAttribute("RequiredDamage"))
				if not requiredDamage then
					requiredDamage = tonumber(visual:GetAttribute("RequiredDamage"))
				end
				table.insert(result, {
					model = container,
					core = core,
					rockType = rockTypeName,
					requiredDamage = requiredDamage,
					visual = visual,
				})
			end
		end
	end
	return result
end

-- Get nearest rock, excluding blacklisted ones
local function getNearestRock(filteredRockTypes, blacklist)
	local hrp = getHumanoidRootPart()
	if not hrp then return nil end
	
	local scanDist = tonumber(oreFarm.scanDistance) or 500
	local allRocks = collectAllRocks(scanDist, hrp.Position)
	
	if #allRocks == 0 then return nil end

	local best
	local bestDist = math.huge
	local currentDmg = tonumber(oreFarm.pickaxeDamage) or 0
	blacklist = blacklist or {}
	
	for _, info in ipairs(allRocks) do
		-- Skip blacklisted rocks
		if not blacklist[info.model] then
			if filteredRockTypes[info.rockType] then
				local req = tonumber(info.requiredDamage)
				if not req or currentDmg >= req then
					local dist = (info.core.Position - hrp.Position).Magnitude
					if dist < bestDist then
						bestDist = dist
						best = info
					end
				end
			end
		end
	end
	return best
end

local movementBusy = false

local tweenSpeed = 85


local function tweenToPosition(targetPos)
    local Character = LocalPlayer.Character
    if not Character then return false end
    local RootPart = Character:FindFirstChild("HumanoidRootPart")
    if not RootPart then return false end
    
    local Dist = (RootPart.Position - targetPos).Magnitude
    local speed = tweenSpeed or 85
    local Time = math.clamp(Dist / speed, 1.5, 8)
    
    
    local cam = workspace.CurrentCamera
    local lookDirection = (targetPos - RootPart.Position).Unit
    local Tween = TweenService:Create(RootPart, TweenInfo.new(Time, Enum.EasingStyle.Linear, Enum.EasingDirection.Out), {
        CFrame = CFrame.lookAt(targetPos, targetPos + lookDirection)
    })
    Tween:Play()
    Tween.Completed:Wait()
    return true
end


local function TweenToTarget(TargetName, IsNPC)
    local Character = LocalPlayer.Character
    if not Character then return false end
    local RootPart = Character:FindFirstChild("HumanoidRootPart")
    if not RootPart then return false end
    
    local Folder = IsNPC and workspace:FindFirstChild("Proximity") or workspace:FindFirstChild("Shops")
    if not Folder then return false end
    
    local Target = Folder:FindFirstChild(TargetName)
    if not Target then return false end
    
    local TargetRoot = Target:FindFirstChild("HumanoidRootPart") or Target.PrimaryPart or Target:FindFirstChildWhichIsA("BasePart", true)
    if not TargetRoot then return false end
    
    local TargetPos = TargetRoot.Position + Vector3.new(0, 3, 0)
    return tweenToPosition(TargetPos)  
end


local function GetAllNPCs()
    AllNPCs = {}
    local Proximity = workspace:FindFirstChild("Proximity")
    if not Proximity then return AllNPCs end
    for _, Child in ipairs(Proximity:GetChildren()) do
        if Child:IsA("Model") and not Child.Name:lower():find("potion") then
            table.insert(AllNPCs, Child.Name)
        end
    end
    table.sort(AllNPCs)
    return AllNPCs
end


local function GetAllShops()
    AllShops = {}
    local Shops = workspace:FindFirstChild("Shops")
    if not Shops then return AllShops end
    for _, Child in ipairs(Shops:GetChildren()) do
        if Child:IsA("Model") then
            table.insert(AllShops, Child.Name)
        end
    end
    table.sort(AllShops)
    return AllShops
end
  

local function getOreNamesForRock(rockModel)
	local names = {}
	local rockFolder = rockModel:FindFirstChild("Rock")
	if not rockFolder then return names end
	for _, inst in ipairs(rockFolder:GetDescendants()) do
		local oreNameAttr = inst:GetAttribute("Ore")
		if oreNameAttr then
			local oreName = tostring(oreNameAttr)
			if oreName ~= "" then
				names[oreName] = true
			end
		end
	end
	return names
end

local function hasDesiredOre(oreNames, desiredSet)
	for name, _ in pairs(oreNames) do
		if desiredSet[name] then
			return true
		end
	end
	return false
end

local function rockHasAnyOre(oreNames)
	for _, _ in pairs(oreNames) do
		return true
	end
	return false
end


local function mineRock(rockInfo, desiredOres)
	local rockModel = rockInfo.model
	local startTick = tick()

	local toolServiceRF = ReplicatedStorage:WaitForChild("Shared"):WaitForChild("Packages"):WaitForChild("Knit"):WaitForChild("Services"):WaitForChild("ToolService"):WaitForChild("RF")
	local toolActivated = toolServiceRF:WaitForChild("ToolActivated")
	local args = { "Pickaxe" }
	local desiredSet = listToSet(desiredOres)
	local maxTime = tonumber(oreFarm.maxRockTime) or 4
	
	while oreFarm.enabled and rockModel.Parent and tick() - startTick < maxTime do
		if isRockDestroyed(rockModel) then
			return "destroyed"
		end
		local core = rockInfo.core
		local hrp = getHumanoidRootPart()
		if core and hrp then
			local dist = (core.Position - hrp.Position).Magnitude
			if dist > 18 then
				return "switch" 
			end
		end

		local oreNames = getOreNamesForRock(rockModel)
		if rockHasAnyOre(oreNames) then
			if hasDesiredOre(oreNames, desiredSet) then
				
				pcall(function()
					toolActivated:InvokeServer(unpack(args))
				end)
				if not rockModel.Parent or isRockDestroyed(rockModel) then
					return "destroyed"
				end
			else
				
				return "switch"
			end
		else
			
			pcall(function()
				toolActivated:InvokeServer(unpack(args))
			end)
		end
		
		local interval = tonumber(oreFarm.mineInterval) or 0.1
		if interval < 0.02 then interval = 0.02 end
		task.wait(interval)
	end
	
	return "timeout"
end


local espObjects = {}

local function clearRocksESP()
	for _, data in pairs(espObjects) do
		if data.highlight then pcall(function() data.highlight:Destroy() end) end
		if data.billboard then pcall(function() data.billboard:Destroy() end) end
		if data.beam then pcall(function() data.beam:Destroy() end) end
		if data.attachment then pcall(function() data.attachment:Destroy() end) end
	end
	table.clear(espObjects)
end

local function ensureESPForRock(rockInfo)
	local model = rockInfo.model
	if not model or not model.Parent then return end
	if espObjects[model] then return end
	local core = rockInfo.core
	if not (core and core:IsA("BasePart")) then return end
	
	
	local highlight = Instance.new("Highlight")
	highlight.FillColor = Color3.fromRGB(0, 255, 200)
	highlight.OutlineColor = Color3.fromRGB(255, 255, 0)
	highlight.FillTransparency = 0.2
	highlight.OutlineTransparency = 0
	highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
	highlight.Enabled = true
	
	
	local visual = rockInfo.visual
	if not visual or not visual.Parent then
		visual = model:FindFirstChild("Boulder") or model:FindFirstChild("Rock") or model
	end
	highlight.Adornee = visual
	
	highlight.Parent = workspace 
    
    

	local attachment0 = Instance.new("Attachment")
	attachment0.Parent = core
	attachment0.Position = Vector3.new(0, 2, 0)
	
	local attachment1 = Instance.new("Attachment")
	attachment1.Parent = core
	attachment1.Position = Vector3.new(0, 20, 0)
	
	local beam = Instance.new("Beam")
	beam.Attachment0 = attachment0
	beam.Attachment1 = attachment1
	beam.Color = ColorSequence.new({
		ColorSequenceKeypoint.new(0, Color3.fromRGB(0, 255, 200)),
		ColorSequenceKeypoint.new(0.5, Color3.fromRGB(100, 200, 255)),
		ColorSequenceKeypoint.new(1, Color3.fromRGB(255, 100, 255))
	})
	beam.Transparency = NumberSequence.new({
		NumberSequenceKeypoint.new(0, 0.3),
		NumberSequenceKeypoint.new(0.5, 0.1),
		NumberSequenceKeypoint.new(1, 0.8)
	})
	beam.Width0 = 0.5
	beam.Width1 = 2
	beam.FaceCamera = true
	beam.LightEmission = 1
	beam.LightInfluence = 0
	beam.Texture = "rbxasset://textures/particles/sparkles_main.dds"
	beam.TextureMode = Enum.TextureMode.Wrap
	beam.TextureSpeed = 1
	beam.Parent = core
	
	
	local billboard = Instance.new("BillboardGui")
	billboard.Size = UDim2.new(0, 150, 0, 50)
	billboard.Adornee = core
	billboard.AlwaysOnTop = true
	billboard.MaxDistance = 1000
	billboard.StudsOffset = Vector3.new(0, 5, 0)
	billboard.Parent = model
	
	
	local bg = Instance.new("Frame")
	bg.Size = UDim2.new(1, 0, 1, 0)
	bg.BackgroundColor3 = Color3.fromRGB(20, 20, 30)
	bg.BackgroundTransparency = 0.3
	bg.BorderSizePixel = 0
	bg.Parent = billboard
	
	local bgCorner = Instance.new("UICorner")
	bgCorner.CornerRadius = UDim.new(0, 8)
	bgCorner.Parent = bg
	
	local bgGradient = Instance.new("UIGradient")
	bgGradient.Color = ColorSequence.new({
		ColorSequenceKeypoint.new(0, Color3.fromRGB(50, 50, 80)),
		ColorSequenceKeypoint.new(1, Color3.fromRGB(20, 20, 40))
	})
	bgGradient.Rotation = 90
	bgGradient.Parent = bg
	
	
	local border = Instance.new("UIStroke")
	border.Color = Color3.fromRGB(0, 255, 200)
	border.Thickness = 2
	border.Transparency = 0
	border.Parent = bg
	

	local label = Instance.new("TextLabel")
	label.Size = UDim2.new(1, -10, 0.6, 0)
	label.Position = UDim2.new(0, 5, 0.1, 0)
	label.BackgroundTransparency = 1
	label.Text = tostring(rockInfo.rockType)
	label.TextColor3 = Color3.fromRGB(0, 255, 200)
	label.TextStrokeTransparency = 0.3
	label.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
	label.TextScaled = true
	label.Font = Enum.Font.GothamBold
	label.Parent = bg
	
	
	local distLabel = Instance.new("TextLabel")
	distLabel.Size = UDim2.new(1, -10, 0.3, 0)
	distLabel.Position = UDim2.new(0, 5, 0.65, 0)
	distLabel.BackgroundTransparency = 1
	distLabel.Text = "..."
	distLabel.TextColor3 = Color3.fromRGB(100, 255, 200)
	distLabel.TextStrokeTransparency = 0.5
	distLabel.TextScaled = true
	distLabel.Font = Enum.Font.Gotham
	distLabel.Parent = bg
	
	espObjects[model] = {
		highlight = highlight,
		billboard = billboard,
		beam = beam,
		attachment = attachment0,
		distLabel = distLabel,
		core = core,
	}
end

local function updateRocksESP()
	if not oreFarm.rocksESPEnabled then
		clearRocksESP()
		return
	end
	
	local hrp = getHumanoidRootPart()
	local origin = hrp and hrp.Position
	local scanDist = tonumber(oreFarm.scanDistance) or 500
	
	
	local rocks = collectAllRocks(scanDist, origin)
	
	
	if origin then
		table.sort(rocks, function(a, b)
			local da = (a.core.Position - origin).Magnitude
			local db = (b.core.Position - origin).Magnitude
			return da < db
		end)
	end

	
	
	local limit = 40
	local activeModels = {}
	
	for i = 1, math.min(#rocks, limit) do
		local info = rocks[i]
		ensureESPForRock(info)
		activeModels[info.model] = true
	end
	
	
	if hrp then
		for model, data in pairs(espObjects) do
			if not activeModels[model] then
				
				if data.highlight then pcall(function() data.highlight:Destroy() end) end
				if data.billboard then pcall(function() data.billboard:Destroy() end) end
				if data.beam then pcall(function() data.beam:Destroy() end) end
				if data.attachment then pcall(function() data.attachment:Destroy() end) end
				espObjects[model] = nil
			elseif data.distLabel and data.core and data.core.Parent then
				local dist = (data.core.Position - hrp.Position).Magnitude
				data.distLabel.Text = string.format("%.0f studs", dist)
			end
		end
	end
end

MainFarmTab:CreateToggle({
	Name = "Rocks ESP",
	CurrentValue = false,
	Flag = "Forge_RocksESP",
	Callback = function(v)
		oreFarm.rocksESPEnabled = v and true or false
		if not oreFarm.rocksESPEnabled then
			clearRocksESP()
		else
			updateRocksESP()
		end
	end,
})

PickaxeDebugParagraph = MainFarmTab:CreateParagraph({
	Title = "Pickaxe Info",
	Content = "Name: ?\nDamage: ?",
})


MainFarmTab:CreateToggle({
    Name = "Fast Attack",
    CurrentValue = false,
    Flag = "FastAttack_Enabled",
    Callback = function(v)
        fuckActive = v and true or false
        if fuckActive then
            startFuckMode()
        else
            stopFuckMode()
        end
        print("FAST ATTACK:", fuckActive and "ON" or "OFF")
    end,
})

MainFarmTab:CreateToggle({
	Name = "Auto Farm Ores",
	CurrentValue = false,
	Flag = "Forge_AutoFarmOres",
	Callback = function(v)
		oreFarm.enabled = v and true or false
		if not oreFarm.enabled then return end
		task.spawn(function()
			local rockBlacklist = {} 
			local blacklistCleanupTimer = 0
			
			while oreFarm.enabled do
				
				if tick() - blacklistCleanupTimer > 30 then
					table.clear(rockBlacklist)
					blacklistCleanupTimer = tick()
				end
				
				
				local pick = ensurePickaxeEquipped()
				if not pick then
					task.wait(0.1)
					updatePickaxeInfoFromGui()
					continue
				end
				
				
				updatePickaxeInfoFromGui()
				
				
				local rockSet = listToSet(oreFarm.selectedRockTypes)
				local targetRock = getNearestRock(rockSet, rockBlacklist)
				if not targetRock then
					
					if #oreFarm.selectedRockTypes > 0 then
						print("[Forge] No rocks matching types: " .. table.concat(oreFarm.selectedRockTypes, ", "))
					else
						print("[Forge] No rock types selected!")
					end
					table.clear(rockBlacklist)
					task.wait(1)
					continue
				end
				print("[Forge] Found target rock: " .. tostring(targetRock.rockType))
				
				
				local core = targetRock.core
				if core and core:IsA("BasePart") then
					pcall(function()
						tweenToPosition(core.Position + Vector3.new(0, 3, 0))
					end)
				end
				
				
				if not oreFarm.enabled then break end
				if not targetRock.model or not targetRock.model.Parent then
					continue
				end
				
				
				local result = mineRock(targetRock, oreFarm.selectedOreTypes)
				
				
				if result == "switch" then
					rockBlacklist[targetRock.model] = true
					print("[Forge] Blacklisted rock with unwanted ore, finding new target...")
				end
				
				
				task.wait(0.1)
			end
		end)
	end,
})


local mobFarm = {
	enabled = false,
	selectedMobs = {},
	attackInterval = 0.1,
	safeHealthPercent = 30,
	mobsESPEnabled = false,
}


local function buildMobOptions()
	local assets = ReplicatedStorage:FindFirstChild("Assets")
	local mobsFolder = assets and assets:FindFirstChild("Mobs")
	local options = {}
	if mobsFolder then
		for _, mob in ipairs(mobsFolder:GetChildren()) do
			if mob.Name and mob.Name ~= "" then
				table.insert(options, mob.Name)
			end
		end
	end
	table.sort(options)
	return options
end

local function normalizeMobName(name)
	
	return (tostring(name):gsub("%d+$", ""))
end

local mobOptions = buildMobOptions()
if #mobOptions == 0 then
	table.insert(mobOptions, "Zombie")
end
if not mobFarm.selectedMobs or #mobFarm.selectedMobs == 0 then
	mobFarm.selectedMobs = { mobOptions[1] }
end


local TeleportSection = MainFarmTab:CreateSection("NPC & Shop Teleport")


local AllNPCs = {}
local SelectedNPC = nil

local function GetAllNPCs()
    AllNPCs = {}
    local Proximity = workspace:FindFirstChild("Proximity")
    if not Proximity then return AllNPCs end
    for _, Child in ipairs(Proximity:GetChildren()) do
        if Child:IsA("Model") and not Child.Name:lower():find("potion") then
            table.insert(AllNPCs, Child.Name)
        end
    end
    table.sort(AllNPCs)
    return AllNPCs
end

MainFarmTab:CreateDropdown({
    Name = "Select NPC",
    Options = GetAllNPCs(),
    CurrentOption = {},
    Flag = "Forge_NPCSelect",
    Callback = function(Selection)
        if typeof(Selection) == "table" and #Selection > 0 then
            SelectedNPC = Selection[1]
        end
    end,
})

MainFarmTab:CreateButton({
    Name = "Refresh NPCs",
    Callback = function()
        local NPCs = GetAllNPCs()
        
        Notify("Teleport", "NPC list refreshed!", 3)
    end,
})

MainFarmTab:CreateButton({
    Name = "Tween to NPC",
    Callback = function()
        if SelectedNPC then
            TweenToTarget(SelectedNPC, true)
        else
            Notify("Teleport", "Select NPC first!", 3)
        end
    end,
})

 
local AllShops = {}
local SelectedShop = nil

local function GetAllShops()
    AllShops = {}
    local Shops = workspace:FindFirstChild("Shops")
    if not Shops then return AllShops end
    for _, Child in ipairs(Shops:GetChildren()) do
        if Child:IsA("Model") then
            table.insert(AllShops, Child.Name)
        end
    end
    table.sort(AllShops)
    return AllShops
end

MainFarmTab:CreateDropdown({
    Name = "Select Shop", 
    Options = GetAllShops(),
    CurrentOption = {},
    Flag = "Forge_ShopSelect",
    Callback = function(Selection)
        if typeof(Selection) == "table" and #Selection > 0 then
            SelectedShop = Selection[1]
        end
    end,
})

MainFarmTab:CreateButton({
    Name = "Refresh Shops",
    Callback = function()
        local Shops = GetAllShops()
        Notify("Teleport", "Shop list refreshed!", 3)
    end,
})

MainFarmTab:CreateButton({
    Name = "Tween to Shop",
    Callback = function()
        if SelectedShop then
            TweenToTarget(SelectedShop, false)
        else
            Notify("Teleport", "Select shop first!", 3)
        end
    end,
})


local MobFarmSection = MainFarmTab:CreateSection("Auto Farm Mobs")

MainFarmTab:CreateDropdown({
	Name = "Mobs to Farm",
	Options = mobOptions,
	MultipleOptions = true,
	CurrentOption = mobFarm.selectedMobs,
	Flag = "Forge_MobTypes",
	Callback = function(opts)
		if type(opts) == "table" and #opts > 0 then
			mobFarm.selectedMobs = opts
		end
	end,
})

MainFarmTab:CreateSlider({
	Name = "Safe HP % (Mobs)",
	Range = { 0, 100 },
	Increment = 5,
	CurrentValue = mobFarm.safeHealthPercent,
	Flag = "Forge_MobSafeHP",
	Callback = function(value)
		mobFarm.safeHealthPercent = value
	end,
})


local function ensureWeaponEquipped()
	local char = getCharacter()
	local hum = getHumanoid()

	for _, t in ipairs(char:GetChildren()) do
		if t:IsA("Tool") and t.Name == "Weapon" then
			return t
		end
	end

	local backpack = LocalPlayer:FindFirstChild("Backpack")
	if not backpack then return nil end
	local weapon = backpack:FindFirstChild("Weapon")
	if not (weapon and weapon:IsA("Tool")) then return nil end
	pcall(function()
		if hum then
			hum:EquipTool(weapon)
		else
			weapon.Parent = char
		end
	end)
	task.wait(0.1)
	return weapon
end


local function isMobDead(model)
	if not model then return false end
	local deadFlag = model:FindFirstChild("Dead", true)
	if deadFlag and deadFlag:IsA("BoolValue") then
		return deadFlag.Value == true
	end
	return false
end


local function collectMobs(selectedSet)
	local living = workspace:FindFirstChild("Living")
	local result = {}
	if not living then return result end
	for _, inst in ipairs(living:GetChildren()) do
		local model = inst
		if model:IsA("Model") then
			
			if isMobDead(model) then
				continue
			end
			local baseName = normalizeMobName(model.Name)
			if selectedSet[baseName] then
				local hrp = model:FindFirstChild("HumanoidRootPart") or model:FindFirstChild("HRP")
				if hrp and hrp:IsA("BasePart") then
					table.insert(result, {
						model = model,
						hrp = hrp,
						mobType = baseName,
					})
				end
			end
		end
	end
	return result
end

local function getNearestMob(selectedSet)
	local mobs = collectMobs(selectedSet)
	if #mobs == 0 then return nil end
	local hrp = getHumanoidRootPart()
	if not hrp then return nil end
	local best
	local bestDist = math.huge
	for _, info in ipairs(mobs) do
		local dist = (info.hrp.Position - hrp.Position).Magnitude
		if dist < bestDist then
			bestDist = dist
			best = info
		end
	end
	return best
end

local function attackMob(mobInfo)
	local mobModel = mobInfo.model
	local hrp = getHumanoidRootPart()
	if not (mobModel and mobModel.Parent and hrp) then return end

	local toolServiceRF = ReplicatedStorage:WaitForChild("Shared"):WaitForChild("Packages"):WaitForChild("Knit"):WaitForChild("Services"):WaitForChild("ToolService"):WaitForChild("RF")
	local toolActivated = toolServiceRF:WaitForChild("ToolActivated")
	local args = { "Weapon" }

	pcall(function()
		toolActivated:InvokeServer(unpack(args))
	end)
end

local function isLowHealthForMobs()
	local hum = getHumanoid()
	if not hum or hum.MaxHealth <= 0 then return false end
	local hpPercent = (hum.Health / hum.MaxHealth) * 100
	local threshold = tonumber(mobFarm.safeHealthPercent) or 0
	return hpPercent <= threshold
end

local function retreatToSafety()
	local hum = getHumanoid()
	local hrp = getHumanoidRootPart()
	if not hum or not hrp then return end

	local startPos = hrp.Position
	local safeHeight = 60
	local safePos = startPos + Vector3.new(0, safeHeight, 0)

	local previousAnchored = hrp.Anchored
	local previousPlatformStand = hum.PlatformStand

	pcall(function()
		tweenToPosition(safePos, oreFarm.tweenSpeed)
		hrp.Anchored = true
		hum.PlatformStand = true
		hrp.CFrame = CFrame.new(safePos)
	end)

	local targetPercent = (tonumber(mobFarm.safeHealthPercent) or 0) + 10
	if targetPercent > 100 then targetPercent = 100 end

	while mobFarm.enabled and hum.Health > 0 and hum.MaxHealth > 0 do
		local hpPercent = (hum.Health / hum.MaxHealth) * 100
		if hpPercent >= targetPercent then
			break
		end
		
		if (hrp.Position - safePos).Magnitude > 3 then
			hrp.CFrame = CFrame.new(safePos)
			hrp.AssemblyLinearVelocity = Vector3.new()
		end
		wait(0.1)
	end

	if not mobFarm.enabled or hum.Health <= 0 or hum.MaxHealth <= 0 then
		hrp.Anchored = previousAnchored
		hum.PlatformStand = previousPlatformStand
		return
	end

	hrp.Anchored = previousAnchored
	hum.PlatformStand = previousPlatformStand

	local returnPos = startPos + Vector3.new(0, 5, 0)
	pcall(function()
		tweenToPosition(returnPos, oreFarm.tweenSpeed)
	end)
end

MainFarmTab:CreateToggle({
	Name = "Auto Farm Mobs",
	CurrentValue = false,
	Flag = "Forge_AutoFarmMobs",
	Callback = function(v)
		mobFarm.enabled = v and true or false
		if not mobFarm.enabled then return end
		task.spawn(function()
			while mobFarm.enabled do
				if isLowHealthForMobs() then
					retreatToSafety()
					continue
				end
				local weapon = ensureWeaponEquipped()
				if not weapon then
					wait(0.1)
					continue
				end

				local selectedSet = listToSet(mobFarm.selectedMobs)
				local target = getNearestMob(selectedSet)
				if not target then
					wait(0.2)
					continue
				end
				
				local mobHrp = target.hrp
				if mobHrp and mobHrp:IsA("BasePart") then
					pcall(function()
						tweenToPosition(mobHrp.Position, oreFarm.tweenSpeed)
					end)
				end
				
				
				if isMobDead(target.model) then
					continue
				end
				
				if not mobFarm.enabled then break end
				if not target.model or not target.model.Parent then
					continue
				end

				attackMob(target)
				local interval = tonumber(mobFarm.attackInterval) or 0.1
				if interval < 0.02 then interval = 0.02 end
				wait(interval)
			end
		end)
	end,
})

-- Mobs ESP
local mobEspObjects = {}

local function clearMobsESP()
	for _, data in pairs(mobEspObjects) do
		if data.highlight then pcall(function() data.highlight:Destroy() end) end
		if data.billboard then pcall(function() data.billboard:Destroy() end) end
		if data.beam then pcall(function() data.beam:Destroy() end) end
		if data.attachment then pcall(function() data.attachment:Destroy() end) end
	end
	table.clear(mobEspObjects)
end

local function ensureESPForMob(mobInfo)
	local model = mobInfo.model
	if not model or not model.Parent then return end
	if mobEspObjects[model] then return end
	local hrp = mobInfo.hrp
	if not (hrp and hrp:IsA("BasePart")) then return end
	
	-- Colorful highlight with glow effect
	local highlight = Instance.new("Highlight")
	highlight.FillColor = Color3.fromRGB(255, 0, 0)
	highlight.OutlineColor = Color3.fromRGB(255, 255, 0)
	highlight.FillTransparency = 0.2
	highlight.OutlineTransparency = 0
	highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
	highlight.Enabled = true
	
	-- Parent to the actual visible parts, not just the container
	highlight.Adornee = model
	
	highlight.Parent = workspace 
    
	-- Animated beam from mob to sky
	local attachment0 = Instance.new("Attachment")
	attachment0.Parent = hrp
	attachment0.Position = Vector3.new(0, 2, 0)
	
	local attachment1 = Instance.new("Attachment")
	attachment1.Parent = hrp
	attachment1.Position = Vector3.new(0, 20, 0)
	
	local beam = Instance.new("Beam")
	beam.Attachment0 = attachment0
	beam.Attachment1 = attachment1
	beam.Color = ColorSequence.new({
		ColorSequenceKeypoint.new(0, Color3.fromRGB(255, 0, 0)),
		ColorSequenceKeypoint.new(0.5, Color3.fromRGB(200, 100, 255)),
		ColorSequenceKeypoint.new(1, Color3.fromRGB(255, 100, 255))
	})
	beam.Transparency = NumberSequence.new({
		NumberSequenceKeypoint.new(0, 0.3),
		NumberSequenceKeypoint.new(0.5, 0.1),
		NumberSequenceKeypoint.new(1, 0.8)
	})
	beam.Width0 = 0.5
	beam.Width1 = 2
	beam.FaceCamera = true
	beam.LightEmission = 1
	beam.LightInfluence = 0
	beam.Texture = "rbxasset://textures/particles/sparkles_main.dds"
	beam.TextureMode = Enum.TextureMode.Wrap
	beam.TextureSpeed = 1
	beam.Parent = hrp
	
	-- Enhanced billboard with gradient background
	local billboard = Instance.new("BillboardGui")
	billboard.Size = UDim2.new(0, 150, 0, 50)
	billboard.Adornee = hrp
	billboard.AlwaysOnTop = true
	billboard.MaxDistance = 1000
	billboard.StudsOffset = Vector3.new(0, 5, 0)
	billboard.Parent = model
	
	-- Background frame with rounded corners
	local bg = Instance.new("Frame")
	bg.Size = UDim2.new(1, 0, 1, 0)
	bg.BackgroundColor3 = Color3.fromRGB(20, 20, 30)
	bg.BackgroundTransparency = 0.3
	bg.BorderSizePixel = 0
	bg.Parent = billboard
	
	local bgCorner = Instance.new("UICorner")
	bgCorner.CornerRadius = UDim.new(0, 8)
	bgCorner.Parent = bg
	
	local bgGradient = Instance.new("UIGradient")
	bgGradient.Color = ColorSequence.new({
		ColorSequenceKeypoint.new(0, Color3.fromRGB(50, 50, 80)),
		ColorSequenceKeypoint.new(1, Color3.fromRGB(20, 20, 40))
	})
	bgGradient.Rotation = 90
	bgGradient.Parent = bg
	
	-- Glowing border
	local border = Instance.new("UIStroke")
	border.Color = Color3.fromRGB(255, 0, 0)
	border.Thickness = 2
	border.Transparency = 0
	border.Parent = bg
	
	-- Mob type label with better styling
	local label = Instance.new("TextLabel")
	label.Size = UDim2.new(1, -10, 0.6, 0)
	label.Position = UDim2.new(0, 5, 0.1, 0)
	label.BackgroundTransparency = 1
	label.Text = tostring(mobInfo.mobType)
	label.TextColor3 = Color3.fromRGB(255, 255, 255)
	label.TextStrokeTransparency = 0.3
	label.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
	label.TextScaled = true
	label.Font = Enum.Font.GothamBold
	label.Parent = bg
	
	-- Distance label
	local distLabel = Instance.new("TextLabel")
	distLabel.Size = UDim2.new(1, -10, 0.3, 0)
	distLabel.Position = UDim2.new(0, 5, 0.65, 0)
	distLabel.BackgroundTransparency = 1
	distLabel.Text = "..."
	distLabel.TextColor3 = Color3.fromRGB(100, 255, 200)
	distLabel.TextStrokeTransparency = 0.5
	distLabel.TextScaled = true
	distLabel.Font = Enum.Font.Gotham
	distLabel.Parent = bg
	
	mobEspObjects[model] = {
		highlight = highlight,
		billboard = billboard,
		beam = beam,
		attachment = attachment0,
		distLabel = distLabel,
		hrp = hrp,
	}
end

local function updateMobsESP()
	if not mobFarm.mobsESPEnabled then
		clearMobsESP()
		return
	end
	local mobs = collectMobs(listToSet(mobFarm.selectedMobs))
	for _, info in ipairs(mobs) do
		ensureESPForMob(info)
	end
	
	-- Update distances
	local hrp = getHumanoidRootPart()
	if hrp then
		for model, data in pairs(mobEspObjects) do
			if data.distLabel and data.hrp and data.hrp.Parent then
				local dist = (data.hrp.Position - hrp.Position).Magnitude
				data.distLabel.Text = string.format("%.0f studs", dist)
			end
		end
	end
end

MainFarmTab:CreateToggle({
	Name = "Mobs ESP",
	CurrentValue = false,
	Flag = "Forge_MobsESP",
	Callback = function(v)
		mobFarm.mobsESPEnabled = v and true or false
		if not mobFarm.mobsESPEnabled then
			clearMobsESP()
		else
			updateMobsESP()
		end
	end,
})

-- Periodic ESP refresh
task.spawn(function()
	while true do
		if oreFarm.rocksESPEnabled then
			updateRocksESP()
		end
		if mobFarm.mobsESPEnabled then
			updateMobsESP()
		end
		updatePickaxeInfoFromGui()
		wait(0.5)
	end
end)

local ForgeTab = Window:CreateTab("Auto Forge", 4483362458)
local StatusSection = ForgeTab:CreateSection("Status")

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local LocalPlayer = Players.LocalPlayer

local autoForge = {
    enabled = false,
    itemType = "Weapon",
    selectedOres = {},
    totalOresPerForge = 3,
    autoMinigames = false,
    mode = "Above",
    weaponThreshold = 10,
    armorThreshold = 10,
}

local StatusParagraph = ForgeTab:CreateParagraph({
    Title = "Status",
    Content = "Idle ",
})

local minigameConnection = nil
local forgeLoop = nil

local function setStatus(text)
    pcall(function()
        if StatusParagraph then
            StatusParagraph:Set({
                Title = "Status",
                Content = text,
            })
        end
    end)
    print("waiting", text)
end

local function getControllers()
    local ok1, uiController = pcall(function()
        return Knit.GetController("UIController")
    end)
    local ok2, forgeController = pcall(function()
        return Knit.GetController("ForgeController")
    end)
    local ok3, playerController = pcall(function()
        return Knit.GetController("PlayerController")
    end)
    
    if ok1 and ok2 and ok3 and uiController and forgeController and playerController then
        local replica = playerController.Replica
        local forgeModule = uiController.Modules and uiController.Modules.Forge
        return forgeController, forgeModule, replica, uiController
    end
    return nil, nil, nil, nil
end

local function buildOreOptions()
    local names = {}
    local ok, arr = pcall(function()
        return Utils.FormArrayFromNames(Ore)
    end)
    if ok and type(arr) == "table" then
        for _, name in ipairs(arr) do
            if type(name) == "string" then table.insert(names, name) end
        end
    else
        for name, _ in pairs(Ore) do
            if type(name) == "string" then table.insert(names, name) end
        end
    end
    table.sort(names)
    return names
end

local oreOptions = buildOreOptions()
if #autoForge.selectedOres == 0 and #oreOptions > 0 then
    autoForge.selectedOres = { oreOptions[1] }
end

local function getCurrentMinigame()
    local forgeGui = LocalPlayer.PlayerGui:FindFirstChild("Forge")
    if not forgeGui then return nil, nil end
    
    local melt = forgeGui:FindFirstChild("MeltMinigame")
    local pour = forgeGui:FindFirstChild("PourMinigame")
    local hammer = forgeGui:FindFirstChild("HammerMinigame")
    
    local function isVisibleSafe(gui)
        local success, result = pcall(function() return gui.Visible end)
        return success and result == true
    end
    
    if melt and isVisibleSafe(melt) then return "Melt", melt
    elseif pour and isVisibleSafe(pour) then return "Pour", pour
    elseif hammer and isVisibleSafe(hammer) then return "Hammer", hammer end
    
    return nil, nil
end

local function autoCompleteMeltMinigame(minigameGui)
    setStatus("🔥 MELT game started")
    
    local heater = minigameGui:FindFirstChild("Heater")
    if not heater then return false end
    
    local top = heater:FindFirstChild("Top")
    local bar = minigameGui:FindFirstChild("Bar")
    if not top or not bar or not bar:FindFirstChild("Area") then return false end
    
    local area = bar.Area
    local cycles = 0
    
    local startTime = tick()
    while minigameGui.Parent and tick() - startTime < 45 do
        local progress = 0
        pcall(function() progress = area.Size.Y.Scale end)
        
        cycles = cycles + 1
        
        
        pcall(function()
            firesignal(top.MouseButton1Down)
            firesignal(top.MouseButton1Click)
        end)
        if typeof(mousedown) == "function" then 
            mousedown(1)
        end
        
        task.wait(0.18) 
        
        
        local cam = workspace.CurrentCamera
        if cam and cam.ViewportSize and typeof(mousemoveabs) == "function" then
            local vs = cam.ViewportSize
            local centerX, centerY = vs.X / 2, vs.Y / 2
            
           
            if typeof(mouse1release) == "function" then 
                mouse1release()
                task.wait(0.01)
                mouse1release() 
            end
            pcall(function()
                for _, conn in ipairs(getconnections(UserInputService.InputEnded)) do
                    conn:Fire({UserInputType = Enum.UserInputType.MouseButton1})
                end
            end)
            
            
            mousemoveabs(centerX, centerY - 45) 
            task.wait(0.05)
            mousemoveabs(centerX, centerY - 25) 
            task.wait(0.03)
            mousemoveabs(centerX, centerY - 8)  
        end
        
        setStatus(string.format("MELT: %.0f%% ↑↑↑ (C:%d)", progress * 100, cycles))
        
        if progress >= 0.92 then
            setStatus(string.format("MELT: %d MAX UP CYCLES", cycles))
            task.wait(1.2)
            return true
        end
        
        task.wait(0.32) 
    end
    return false
end

local function autoCompletePourMinigame(minigameGui)
    setStatus("POUR game started")
    
    local VirtualInputManager = game:GetService("VirtualInputManager")
    local frame = minigameGui:FindFirstChild("Frame")
    if not frame then return false end
    
    local line = frame:FindFirstChild("Line")
    local area = frame:FindFirstChild("Area")
    if not line or not area then return false end
    
    local timer = minigameGui:FindFirstChild("Timer")
    if not timer or not timer:FindFirstChild("Bar") then return false end
    
    local cam = workspace.CurrentCamera
    local totalCycles = 0
    
    
    local startTime = tick()
    while minigameGui.Parent and tick() - startTime < 60 do  
        local progress = 0
        local linePos = 0
        local areaPos = 0
        local areaSize = 0
        
        pcall(function()
            progress = timer.Bar.Size.X.Scale
            linePos = line.Position.Y.Scale
            areaPos = area.Position.Y.Scale
            areaSize = area.Size.Y.Scale
        end)
        
        local boxTop = areaPos
        local boxBottom = areaPos + areaSize
        local error = linePos - (areaPos + areaSize * 0.5)
        
        local vs = cam.ViewportSize
        local pixelX, pixelY = vs.X / 2, ((areaPos + areaSize * 0.5) * vs.Y)
        
        
        if linePos > boxBottom - 0.02 then
            VirtualInputManager:SendMouseButtonEvent(pixelX, pixelY, 0, true, game, 0)
            setStatus(string.format("POUR: %.0f%% HOLD↑ (L:%.3f)", progress * 100, linePos))
        elseif linePos < boxTop + 0.02 then
            VirtualInputManager:SendMouseButtonEvent(pixelX, pixelY, 0, false, game, 0)
            setStatus(string.format("POUR: %.0f%% RELEASE↓ (L:%.3f)", progress * 100, linePos))
        else
            setStatus(string.format("POUR: %.0f%% PERFECT (L:%.3f)", progress * 100, linePos))
        end
        
        totalCycles = totalCycles + 1
        
        
        if progress >= 0.97 and not minigameGui.Parent then
            VirtualInputManager:SendMouseButtonEvent(pixelX, pixelY, 0, false, game, 0)
            setStatus("✅ POUR almost done")
            return true
        end
        
        task.wait(0.018)
    end
    
    
    local vs = cam.ViewportSize
    local pixelX, pixelY = vs.X / 2, vs.Y / 2
    VirtualInputManager:SendMouseButtonEvent(pixelX, pixelY, 0, false, game, 0)
    setStatus(string.format("POUR: FINISHED (C:%d)", totalCycles))
    return true  
end

local function autoCompleteHammerMinigame(minigameGui)
    setStatus("HAMMER: game started")
    task.spawn(function()
        for i = 1, 400 do
            for _, obj in ipairs(workspace.Debris:GetChildren()) do
                pcall(function()
                    local cd = obj:FindFirstChildWhichIsA("ClickDetector", true)
                    if cd then
                        for _, conn in ipairs(getconnections(cd.MouseClick)) do conn:Fire() end
                    end
                end)
            end
            task.wait(0.01)
        end
    end)
    
    local notes = 0
    task.spawn(function()
        while minigameGui.Parent do
            for _, note in ipairs(minigameGui:GetChildren()) do
                if note.Name == "Frame" then
                    pcall(function()
                        local inner = note:FindFirstChild("Frame")
                        if inner then
                            local circle = inner:FindFirstChild("Circle")
                            local border = inner:FindFirstChild("Border")
                            if circle and border and math.abs(circle.Size.Y.Scale - border.Size.Y.Scale) < 0.08 then
                                for _, conn in ipairs(getconnections(note.MouseButton1Click)) do conn:Fire() end
                                notes = notes + 1
                            end
                        end
                    end)
                end
            end
            task.wait(0.005)
        end
    end)
    
    task.wait(5)
    setStatus("HAMMER: " .. notes .. " notes")
    return true
end

local function startMinigameDetector()
    if minigameConnection then minigameConnection:Disconnect() end
    
    minigameConnection = RunService.Heartbeat:Connect(function()
        if not autoForge.autoMinigames then return end
        local name, gui = getCurrentMinigame()
        if name and gui then
            setStatus("FIX: " .. name)
            task.spawn(function()
                if name == "Melt" then autoCompleteMeltMinigame(gui)
                elseif name == "Pour" then autoCompletePourMinigame(gui)
                elseif name == "Hammer" then autoCompleteHammerMinigame(gui) end
            end)
        end
    end)
end


local function computeRecipeFromInventory(replica)
    local inv = replica and replica.Data and replica.Data.Inventory or {}
    local needed = autoForge.totalOresPerForge or 3
    local recipe = {}
    local count = 0
    
    if not autoForge.selectedOres or #autoForge.selectedOres == 0 then
        return nil, "No ores selected"
    end
    
    while count < needed do
        local progressed = false
        for _, oreName in ipairs(autoForge.selectedOres) do
            if count >= needed then break end
            local have = inv[oreName] or 0
            local used = recipe[oreName] or 0
            if have > used then
                recipe[oreName] = used + 1
                count += 1
                progressed = true
            end
        end
        if not progressed then break end
    end
    
    return count >= 3 and recipe or nil, count < 3 and "Not enough ores" or nil
end

local function rebuildRecipe(forgeModule, forgeGui, recipeOres)
    pcall(function()
        if not forgeModule or not forgeGui then return end
        forgeModule.addedOres = {}
        local oreSelect = forgeGui:FindFirstChild("OreSelect")
        if not oreSelect then return end
        
        local oresContainer = oreSelect:FindFirstChild("Forge")
        if oresContainer then oresContainer = oresContainer:FindFirstChild("Ores") end
        if not oresContainer then return end
        
        for _, btn in ipairs(oresContainer:GetChildren()) do
            if btn:IsA("GuiObject") then btn:Destroy() end
        end
        
        for oreName, count in pairs(recipeOres or {}) do
            if type(count) == "number" and count > 0 then
                for _ = 1, count do forgeModule:AddOre(oreName) end
            end
        end
        
        forgeModule.selectedItemType = autoForge.itemType
        pcall(forgeModule.UpdateProbabilities, forgeModule)
        pcall(forgeModule.UpdateAddedOres, forgeModule)
    end)
end

local function waitForEndScreen(uiController)
    local start = tick()
    while tick() - start < 30 and autoForge.enabled do
        local forgeRoot = LocalPlayer.PlayerGui:FindFirstChild("Forge")
        local endScreen = forgeRoot and forgeRoot:FindFirstChild("EndScreen")
        if endScreen then
            local ok, enabled = pcall(function() return endScreen.Enabled end)
            if ok and enabled or endScreen.Visible then return endScreen end
        end
        RunService.RenderStepped:Wait()
    end
    return nil
end

local function evaluateAndClickEndScreen()
    local forgeGui = LocalPlayer.PlayerGui:FindFirstChild("Forge")
    if not forgeGui then return end
    local endRoot = forgeGui:FindFirstChild("EndScreen")
    if not endRoot then return end

    local statsFrame = endRoot:FindFirstChild("Stats")
    if not statsFrame then return end
    local frame = statsFrame:FindFirstChild("Frame")
    if not frame then return end
    local list = frame:FindFirstChild("List")
    if not list then return end
    local stats = list:FindFirstChild("Stats")
    if not stats then return end
    local damage = stats:FindFirstChild("Damage")
    if not damage then return end
    local statHolder = damage:FindFirstChild("Stat")
    if not statHolder then return end
    local statLabel = statHolder:FindFirstChild("Stat")
    if not statLabel or not statLabel:IsA("TextLabel") then return end

    local text = tostring(statLabel.Text or "")
    local numeric = tonumber(text:match("^(%d+%.?%d*)")) or 0
    local mode = autoForge.mode
    local threshold = autoForge.itemType == "Armor" and autoForge.armorThreshold or autoForge.weaponThreshold
    local pass = mode == "Above" and numeric >= threshold or mode == "Below" and numeric <= threshold
    
    local buttonsRoot = frame
    local accept = buttonsRoot:FindFirstChild("AcceptButton")
    local remove = buttonsRoot:FindFirstChild("RemoveButton")

    if pass and accept then
        setStatus("ACCEPT " .. numeric)
        pcall(function()
            if typeof(mouse1click) == "function" then
                local pos = accept.AbsolutePosition
                local size = accept.AbsoluteSize
                local cx, cy = pos.X + size.X/2, pos.Y + size.Y/2
                if typeof(mousemoveabs) == "function" then mousemoveabs(cx, cy) end
                task.wait()
                mouse1click()
            end
        end)
    elseif remove then
        setStatus("DELETE " .. numeric)
        pcall(function()
            local pos = remove.AbsolutePosition
            local size = remove.AbsoluteSize
            local cx, cy = pos.X + size.X/2, pos.Y + size.Y/2
            if typeof(mousemoveabs) == "function" then mousemoveabs(cx, cy) end
            task.wait()
            if typeof(mouse1click) == "function" then mouse1click() end
        end)
    end
end

local function waitAndPlayMinigames()
    local timeout = tick() + 120
    while tick() < timeout and autoForge.enabled do
        local minigameName, minigameGui = getCurrentMinigame()
        if minigameName then
            if minigameName == "Melt" then autoCompleteMeltMinigame(minigameGui)
            elseif minigameName == "Pour" then autoCompletePourMinigame(minigameGui)
            elseif minigameName == "Hammer" then autoCompleteHammerMinigame(minigameGui) end
            task.wait(2)
        end
        
        local forgeRoot = LocalPlayer.PlayerGui:FindFirstChild("Forge")
        local endScreen = forgeRoot and forgeRoot:FindFirstChild("EndScreen")
        if endScreen and (endScreen.Enabled or endScreen.Visible) then
            evaluateAndClickEndScreen()
            return true
        end
        task.wait(0.5)
    end
    return false
end

local function runAutoForgeLoop()
    while autoForge.enabled do
        local forgeController, forgeModule, replica, uiController = getControllers()
        if not forgeController or not forgeController.ForgeActive then
            setStatus("Open Forge first!")
            task.wait(3) continue
        end
        
        local forgeGui = uiController.PlayerGui:FindFirstChild("Forge")
        if not forgeGui then task.wait(2) continue end
        
        local recipe, err = computeRecipeFromInventory(replica)
        if not recipe then
            setStatus("" .. (err or "No recipe"))
            task.wait(5) continue
        end
        
        rebuildRecipe(forgeModule, forgeGui, recipe)
        pcall(function() forgeController:ChangeSequence("Melt") end)
        
        if autoForge.autoMinigames then waitAndPlayMinigames() end
        
        local endScreen = waitForEndScreen(uiController)
        if endScreen then evaluateAndClickEndScreen() end
        
        task.wait(3)
    end
end


ForgeTab:CreateToggle({
    Name = "Auto Forge", CurrentValue = false, 
    Flag = "AutoForge_Enabled",
    Callback = function(value)
        autoForge.enabled = value
        if value and not forgeLoop then
            forgeLoop = task.spawn(runAutoForgeLoop)
            setStatus("auto forge started")
        elseif not value and forgeLoop then
            task.cancel(forgeLoop) forgeLoop = nil
            setStatus("Full auto OFF")
        end
    end,
})

ForgeTab:CreateToggle({
    Name = "Auto Minigames", CurrentValue = false, 
    Flag = "AutoForge_AutoMinigames",
    Callback = function(value)
        autoForge.autoMinigames = value
        if value then
            startMinigameDetector()
            setStatus("AUTO MINIGAME ON")
        else
            if minigameConnection then minigameConnection:Disconnect() minigameConnection = nil end
            setStatus("AUTO MINIGAME OFF")
        end
    end,
})

ForgeTab:CreateDropdown({
Name = "Item Type", 
Options = {"Weapon", "Armor"}, 
CurrentOption = {autoForge.itemType}, MultipleOptions = false,
    Callback = function(opts) 
        local v = type(opts) == "table" and opts[1] or opts
        if v == "Weapon" or v == "Armor" then autoForge.itemType = v end
    end})

ForgeTab:CreateDropdown({
Name = "Ores", 
Options = oreOptions, 
MultipleOptions = true, 
CurrentOption = autoForge.selectedOres,
    Callback = function(opts) if type(opts) == "table" then autoForge.selectedOres = opts end end})

ForgeTab:CreateSlider({
Name = "Ores Per Forge", 
Range = {3, 10}, 
Increment = 1, 
CurrentValue = autoForge.totalOresPerForge,
    Callback = function(value) autoForge.totalOresPerForge = math.floor(value) end})

ForgeTab:CreateDropdown({
Name = "Mode", 
Options = {"Above", "Below"}, 
CurrentOption = {autoForge.mode}, 
MultipleOptions = false,
    Callback = function(opts) 
        local v = type(opts) == "table" and opts[1] or opts
        if v == "Above" or v == "Below" then autoForge.mode = v end
    end})

ForgeTab:CreateSlider({
Name = "Weapon Threshold", 
Range = {1, 100}, 
Increment = 1, 
CurrentValue = autoForge.weaponThreshold,
    Callback = function(value) autoForge.weaponThreshold = math.floor(value) end})

ForgeTab:CreateSlider({
Name = "Armor Threshold", 
Range = {1, 100}, 
Increment = 1, 
CurrentValue = autoForge.armorThreshold,
    Callback = function(value) autoForge.armorThreshold = math.floor(value) end})

setStatus("waiting")

-- AUTO POTIONS

local AutoTab = Window:CreateTab("Auto", 4483362458)
local AutoPotSection = AutoTab:CreateSection("auto use poitions")

local autoPotions = {
	enabled = false,
	selected = {},
}

local AutoPotStatus = AutoTab:CreateParagraph({
	Title = "Potions Status",
	Content = "Idle",
})

local function setPotionStatus(text)
	if AutoPotStatus then
		AutoPotStatus:Set({
			Title = "Potions Status",
			Content = text,
		})
	end
	print("[Auto Potions]", text)
end

local function buildPotionOptions()
	local potFolder = ReplicatedStorage:FindFirstChild("Assets")
	potFolder = potFolder and potFolder:FindFirstChild("Extras") or nil
	potFolder = potFolder and potFolder:FindFirstChild("Potion") or nil
	local names = {}
	if potFolder then
		for _, inst in ipairs(potFolder:GetChildren()) do
			if inst.Name and typeof(inst.Name) == "string" then
				table.insert(names, inst.Name)
			end
		end
	end
	table.sort(names)
	return names
end

local potionOptions = buildPotionOptions()

AutoTab:CreateDropdown({
	Name = "Potions to Auto-Use",
	Options = potionOptions,
	MultipleOptions = true,
	CurrentOption = autoPotions.selected,
	Flag = "Auto_Potions_List",
	Callback = function(opts)
		if type(opts) == "table" and #opts > 0 then
			autoPotions.selected = opts
		else
			autoPotions.selected = {}
		end
	end,
})

local function autoPotionLoop()
	local toolRF = ReplicatedStorage
		:WaitForChild("Shared")
		:WaitForChild("Packages")
		:WaitForChild("Knit")
		:WaitForChild("Services")
		:WaitForChild("ToolService")
		:WaitForChild("RF")
		:WaitForChild("ToolActivated")

	setPotionStatus("Auto potions running...")
	while autoPotions.enabled do
		if #autoPotions.selected == 0 then
			setPotionStatus("No potions selected")
			wait(1)
		else
			local usedSomething = false
			for _, potionName in ipairs(autoPotions.selected) do
				local backpack = LocalPlayer:FindFirstChild("Backpack")
				local tool = backpack and backpack:FindFirstChild(potionName)
				if tool and tool:IsA("Tool") then
					setPotionStatus("Using potion: " .. potionName)
					-- Equip tool
					pcall(function()
						LocalPlayer.Character.Humanoid:EquipTool(tool)
					end)
					-- Invoke server to activate
					pcall(function()
						toolRF:InvokeServer(potionName)
					end)
					usedSomething = true
				end
			end
			if not usedSomething then
				setPotionStatus("No selected potions found in backpack")
			end
			wait(1)
		end
	end
	setPotionStatus("Auto potions stopped")
end

AutoTab:CreateToggle({
	Name = "Enable Auto Potions",
	CurrentValue = false,
	Flag = "Auto_Potions_Enable",
	Callback = function(v)
		autoPotions.enabled = v
		if autoPotions.enabled then
			setPotionStatus("Starting auto potions...")
			spawn(autoPotionLoop)
		else
			setPotionStatus("Stopped")
		end
	end,
})

-- AUTO PLAYER MOVEMENT

local autoMovement = {
	alwaysRun = false,
	autoDodge = false,
}

local AutoMoveSection = AutoTab:CreateSection("auto player movement")

local function runCharacter()
	pcall(function()
		local CharacterService = Knit.GetService("CharacterService")
		CharacterService:Run()
	end)
end

local function stopRunCharacter()
	pcall(function()
		local CharacterService = Knit.GetService("CharacterService")
		CharacterService:StopRun()
	end)
end

--// Dash remote (add this at the top with your other services)
local DashRemote = game:GetService("ReplicatedStorage")
    :WaitForChild("Shared")
    :WaitForChild("Packages")
    :WaitForChild("Knit")
    :WaitForChild("Services")
    :WaitForChild("CharacterService")
    :WaitForChild("RF")
    :WaitForChild("Dash")

local function dashAwayFromTarget(humanoid, hrp, targetPart)
    if not (humanoid and hrp and targetPart) then return end
    
    pcall(function()
        local toEnemy = (targetPart.Position - hrp.Position)
        local flat = Vector3.new(toEnemy.X, 0, toEnemy.Z)
        if flat.Magnitude < 0.1 then return end
        local away = -flat.Unit
        local rootCF = hrp.CFrame
        local look = rootCF.LookVector
        local right = rootCF.RightVector
        look = Vector3.new(look.X, 0, look.Z).Unit
        right = Vector3.new(right.X, 0, right.Z).Unit
        local dotL = look:Dot(away)
        local dotR = right:Dot(away)
        local dir, sign
        if math.abs(dotL) >= math.abs(dotR) then
            if dotL >= 0 then
                dir, sign = "LookVector", "+"
            else
                dir, sign = "LookVector", "-"
            end
        else
            if dotR >= 0 then
                dir, sign = "RightVector", "+"
            else
                dir, sign = "RightVector", "-"
            end
        end
        
        -- Use remote instead of service:Dash
        DashRemote:InvokeServer(dir, sign)
    end)
end

-- Your autoMovementLoop stays exactly the same
local autoMovementRunning = false

local function autoMovementLoop()
    if autoMovementRunning then return end
    autoMovementRunning = true
    local lastHealth
    local lastDodgeTime = 0
    while autoMovement.alwaysRun or autoMovement.autoDodge do
        local char = LocalPlayer and LocalPlayer.Character or nil
        local humanoid = char and char:FindFirstChildOfClass("Humanoid") or nil
        local hrp = char and char:FindFirstChild("HumanoidRootPart") or nil
        
        if humanoid and hrp then
            local health = humanoid.Health
            
            if autoMovement.alwaysRun and humanoid.MoveDirection.Magnitude > 0.1 then
                runCharacter()
            end
            
            if autoMovement.autoDodge then
                local livingFolder = Workspace:FindFirstChild("Living")
                if livingFolder then
                    local detectRange = 40
                    for _, model in ipairs(livingFolder:GetChildren()) do
                        if model ~= char and model:FindFirstChild("Status") then
                            local status = model.Status
                            local attackingValue = status:FindFirstChild("Attacking")
                            
                            if attackingValue and attackingValue.Value then
                                local enemyHRP = model:FindFirstChild("HumanoidRootPart") or model.PrimaryPart
                                if enemyHRP then
                                    local dist = (enemyHRP.Position - hrp.Position).Magnitude
                                    if dist < detectRange and time() - lastDodgeTime > 1 then
                                        print("[AUTO DODGE ATTACKER]", model.Name, math.floor(dist).." studs")
                                        dashAwayFromTarget(humanoid, hrp, enemyHRP)
                                        lastDodgeTime = time()
                                        break
                                    end
                                end
                            end
                        end
                    end
                end
                
                if lastHealth and health < lastHealth - 0.5 and health > 0 then
                    lastDodgeTime = time()
                end
            end
            
            lastHealth = health
        else
            lastHealth = nil
        end
        wait(0.05)
    end
    autoMovementRunning = false
end

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Workspace = game:GetService("Workspace")
local RunService = game:GetService("RunService")
local Debris = game:GetService("Debris")
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer

local autoBlock = {enabled = false, aura = false}
local detectRange = 15

local startBlockRemote, stopBlockRemote
pcall(function()
    local rf = ReplicatedStorage.Shared.Packages.Knit.Services.ToolService.RF
    startBlockRemote = rf.StartBlock
    stopBlockRemote = rf.StopBlock
end)


local function spawnProtectionDebris(char)
    pcall(function()
        local parryEffect = ReplicatedStorage.Assets.Effects.Parry:Clone()
        parryEffect.CFrame = char.HumanoidRootPart.CFrame
        parryEffect.Parent = Workspace.Debris or Workspace
        
        for _, v in parryEffect:GetDescendants() do
            if v:IsA("ParticleEmitter") then
                v:Emit(50)
            end
        end
        Debris:AddItem(parryEffect, 1.5)
    end)
end

local function perfectBlockAura()
    local char = LocalPlayer.Character
    if not char or not char:FindFirstChild("HumanoidRootPart") then return end
    
    
    if startBlockRemote then
        pcall(startBlockRemote.InvokeServer, startBlockRemote)
    end
    
    
    spawnProtectionDebris(char)
    
    print("🎯 PERFECT BLOCK + DEBRIS!")
end

local function checkLivingStatus()
    local char = LocalPlayer.Character
    if not char or not char:FindFirstChild("HumanoidRootPart") then return end
    
    local hrp = char.HumanoidRootPart
    local livingFolder = Workspace:FindFirstChild("Living")
    if not livingFolder then return end
    
    local auraRange = autoBlock.aura and 40 or detectRange
    
    for _, enemy in ipairs(livingFolder:GetChildren()) do
        if enemy ~= char and enemy:FindFirstChild("Status") then
            local enemyHRP = enemy:FindFirstChild("HumanoidRootPart")
            if enemyHRP then
                local dist = (enemyHRP.Position - hrp.Position).Magnitude
                if dist <= auraRange then
                    
                    local attackingValue = enemy.Status:FindFirstChild("Attacking")
                    if attackingValue and attackingValue.Value then
                        print("[PERFECT AUTO BLOCK]", autoBlock.aura and "AURA" or "NORMAL", enemy.Name, math.floor(dist).." studs")
                        
                        if autoBlock.aura then
                            perfectBlockAura() 
                        else
                            pcall(startBlockRemote.InvokeServer, startBlockRemote)
                            spawnProtectionDebris(char)
                        end
                        return true
                    end
                end
            end
        end
    end
    return false
end

local function autoBlockLoop()
    while autoBlock.enabled do
        pcall(checkLivingStatus)
        task.wait(autoBlock.aura and 0.005 or 0.02)  
    end
end


AutoTab:CreateSlider({
    Name = "Detect Range", 
    Range = {10, 50}, 
    Increment = 1, 
    CurrentValue = 15, 
    Flag = "PerfectBlock_Range", 
    Callback = function(v) 
        detectRange = v 
        print("Range:", v)
    end
})

AutoTab:CreateToggle({
    Name = "Auto Block", 
    CurrentValue = false, 
    Flag = "Perfect_Auto_Block", 
    Callback = function(v) 
        autoBlock.enabled = v
        if v then 
            task.spawn(autoBlockLoop)
            print("AUTO BLOCK ON")
        else
            print("AUTO BLOCK OFF")
        end
    end
})

AutoTab:CreateToggle({
    Name = "Block Aura Always Block)", 
    CurrentValue = false, 
    Flag = "Perfect_Block_Aura", 
    Callback = function(v) 
        autoBlock.aura = v
        print(v and "Block Aura ON" or "Aura OFF")
    end
})

AutoTab:CreateToggle({
	Name = "Always Run",
	CurrentValue = false,
	Flag = "Auto_Move_AlwaysRun",
	Callback = function(v)
		autoMovement.alwaysRun = v
		if not v then
			stopRunCharacter()
		end
		if autoMovement.alwaysRun or autoMovement.autoDodge then
			spawn(autoMovementLoop)
		end
	end,
})

AutoTab:CreateToggle({
	Name = "Auto Dodge (dash on hit)",
	CurrentValue = false,
	Flag = "Auto_Move_AutoDodge",
	Callback = function(v)
		autoMovement.autoDodge = v
		if autoMovement.alwaysRun or autoMovement.autoDodge then
			spawn(autoMovementLoop)
		end
	end,
})

local AutoSellTab = Window:CreateTab("Auto Sell", 4483362458)

local autoSell = {
    enabled = false,
    selectedOres = {},
    selectedInvItems = {},
    interval = 10,
    sellAmount = 100,
}

local currentInvOptions = {"Click Refresh Inventory"}

local function listToSet(list)
    local set = {}
    for _, item in ipairs(list or {}) do
        set[item] = true
    end
    return set
end

local function getInventoryFromUI()
    local inv = {}
    local pg = LocalPlayer:FindFirstChild("PlayerGui")
    if not pg then return inv end
    
    local menu = pg:FindFirstChild("Menu")
    local frame1 = menu and menu:FindFirstChild("Frame")
    local frame2 = frame1 and frame1:FindFirstChild("Frame")
    local menus = frame2 and frame2:FindFirstChild("Menus")
    local stash = menus and menus:FindFirstChild("Stash")
    local container = stash and stash:FindFirstChild("Background")
    
    if not container then 
        container = stash 
    end
    
    if not container then return inv end
    
    for _, itemFrame in ipairs(container:GetChildren()) do
        pcall(function()
            local main = itemFrame:FindFirstChild("Main")
            if main then
                local nameLbl = main:FindFirstChild("ItemName") or main:FindFirstChild("Name")
                local qtyLbl = main:FindFirstChild("Quantity") or main:FindFirstChild("Count")
                
                if nameLbl and qtyLbl then
                    local name = nameLbl.Text
                    local qtyStr = qtyLbl.Text:match("%d+") or "0"
                    local qty = tonumber(qtyStr) or 0
                    
                    if name and name ~= "" and qty > 0 then
                        inv[name] = qty
                        print("[AutoSell] Found:", name, "x", qty)
                    end
                end
            end
        end)
    end
    
    return inv
end

local InvDropdown

local function RefreshInventoryList()
    local inv = getInventoryFromUI()
    local options = {}
    
    for name, qty in pairs(inv) do
        table.insert(options, name .. " (x" .. qty .. ")")
    end
    
    table.sort(options)
    if #options == 0 then
        options = {"Open Stash → Refresh"}
    end
    
    currentInvOptions = options
    print("[AutoSell] Refreshed. Found:", #options, "items")
    
    if InvDropdown then
        InvDropdown:Refresh(currentInvOptions, {})
    end
end

local function performAutoSell()
    local inv = getInventoryFromUI()
    local basket = {}
    
    local oreSet = listToSet(autoSell.selectedOres)
    local invSet = {}
    for _, opt in ipairs(autoSell.selectedInvItems) do
        local name = opt:match("^(.-) %(x%d+%)$") or opt
        invSet[name] = true
    end
    
    for itemName, amount in pairs(inv) do
        if oreSet[itemName] or invSet[itemName] then
            local sellQty = math.min(amount, autoSell.sellAmount)
            basket[itemName] = sellQty
        end
    end
    
    if next(basket) then
        print("[DEBUG] Basket:", HttpService:JSONEncode(basket))
        
        
        local remotePaths = {
            {"ReplicatedStorage", "Shared", "Packages", "Knit", "Services", "DialogueService", "RF", "RunCommand"},
            {"ReplicatedStorage", "Remotes", "SellItems"},
            {"ReplicatedStorage", "SellRemote"},
            {"ReplicatedStorage", "Shared", "Remotes", "SellConfirm"},
            {"ReplicatedStorage", "Knit", "Services", "ShopService", "RF", "Sell"},
            {"ReplicatedStorage", "Shared", "Packages", "Knit", "Controllers", "ShopController", "RF", "SellItems"},
        }
        
        local success = false
        for i, path in ipairs(remotePaths) do
            local remote = game.ReplicatedStorage
            local found = true
            
            for j = 2, #path do
                local child = remote:FindFirstChild(path[j])
                if not child then 
                    found = false 
                    break 
                end
                remote = child
            end
            
            if found and remote then
                print("[DEBUG] Trying path", i, ":", path[#path])
                local args = {"SellConfirm", {Basket = basket}}
                
                local ok, err = pcall(function()
                    remote:InvokeServer(unpack(args))
                end)
                
                if ok then
                    print("[SUCCESS] Path", i, "WORKED!")
                    setStatus("SOLD: " .. HttpService:JSONEncode(basket))
                    success = true
                    break
                else
                    print("[DEBUG] Path", i, "failed:", err)
                end
            end
            task.wait(0.1)
        end
        
        if not success then
            setStatus("No sell remote found")
        end
    else
        setStatus("No items selected")
    end
end


AutoSellTab:CreateToggle({
    Name = "Enable Auto Sell",
    CurrentValue = false,
    Flag = "Forge_AutoSellEnabled",
    Callback = function(v)
        autoSell.enabled = v
        if v then
            task.spawn(function()
                while autoSell.enabled do
                    performAutoSell()
                    task.wait(autoSell.interval)
                end
            end)
        end
    end,
})

AutoSellTab:CreateDropdown({
    Name = "Ores to Auto Sell",
    Options = oreOptions,
    MultipleOptions = true,
    CurrentOption = autoSell.selectedOres,
    Flag = "Forge_AutoSellOres",
    Callback = function(opts)
        autoSell.selectedOres = opts or {}
    end,
})

AutoSellTab:CreateButton({
    Name = "🔄 Refresh Inventory",
    Callback = RefreshInventoryList,
})

InvDropdown = AutoSellTab:CreateDropdown({
    Name = "Inventory Items",
    Options = currentInvOptions,
    MultipleOptions = true,
    CurrentOption = {},
    Flag = "Forge_AutoSellInvItems",
    Callback = function(opts)
        autoSell.selectedInvItems = opts or {}
    end,
})

AutoSellTab:CreateSlider({
    Name = "Sell Amount",
    Range = {1, 1000},
    Increment = 1,
    CurrentValue = 100,
    Flag = "Forge_AutoSellAmount",
    Callback = function(v)
        autoSell.sellAmount = v
    end,
})

AutoSellTab:CreateSlider({
    Name = "Sell Interval (s)",
    Range = {5, 120},
    Increment = 5,
    CurrentValue = 10,
    Flag = "Forge_AutoSellInterval",
    Callback = function(v)
        autoSell.interval = v
    end,
})

local SettingsTab = Window:CreateTab("Settings", 4483362458)

-- Noclip functionality
local noclipActive = false
local noclipConnection

noclipConnection=nil
noclipActive=false

function enableNoclip()
if noclipConnection then return end
noclipConnection=RunService.Stepped:Connect(function()
local char=getCharacter()
if not noclipActive or not char then return end
for _,part in ipairs(char:GetDescendants())do
if part:IsA("BasePart")then
part.CanCollide=false
end
end
end)
print("[Noclip] Enabled")
end

function disableNoclip()
if noclipConnection then
noclipConnection:Disconnect()
noclipConnection=nil
end
local char=getCharacter()
if char then
for _,part in ipairs(char:GetDescendants())do
if part:IsA("BasePart")then
part.CanCollide=true
end
end
end
print("[Noclip] Disabled")
end

-- Velocity-based movement for ore/zombie targeting
local function velocityTweenToPosition(targetPos, speed)
	local hrp = getHumanoidRootPart()
	if not hrp then return end
	
	while movementBusy do
		RunService.Heartbeat:Wait()
	end
	movementBusy = true
	
	speed = speed or oreFarm.tweenSpeed or 85
	local distance = (targetPos - hrp.Position).Magnitude
	local duration = math.max(0.5, distance / math.max(50, speed))
	
	local velocity = Instance.new("BodyVelocity")
	velocity.MaxForce = Vector3.new(1, 1, 1) * 1e9
	velocity.P = 10000
	velocity.Velocity = Vector3.zero
	velocity.Parent = hrp
	
	local startTime = tick()
	local connection
	connection = RunService.RenderStepped:Connect(function()
		if not hrp or not hrp.Parent then
			velocity:Destroy()
			connection:Disconnect()
			movementBusy = false
			return
		end
		
		local elapsed = tick() - startTime
		if elapsed >= duration then
			velocity.Velocity = Vector3.zero
			velocity:Destroy()
			connection:Disconnect()
			movementBusy = false
			return
		end
		
		local currentPos = hrp.Position
		local direction = (targetPos - currentPos)
		if direction.Magnitude > 0.5 then
			velocity.Velocity = direction.Unit * speed
		else
			velocity.Velocity = Vector3.zero
		end
	end)
end

MovementSection=SettingsTab:CreateSection("Movement & Noclip") SettingsTab:CreateToggle({Name="Noclip (Farm Mode)",CurrentValue=false,Flag="Noclip_Enabled",Callback=function(v)noclipActive=v;if v then enableNoclip()else disableNoclip()end end})

-- Put at END of script (0 locals added!)
antiAfk = antiAfk or {enabled=true, running=false, interval=60, key=Enum.KeyCode.ButtonR3, bindName="PVB_AntiAFK"}

-- INLINE FUNCTIONS (no local function names)
pcall(function() game:GetService("ContextActionService"):UnbindAction(antiAfk.bindName) end)
game:GetService("ContextActionService"):BindAction(antiAfk.bindName, function() return Enum.ContextActionResult.Sink end, false, antiAfk.key)

-- SINGLE INLINE LOOP
if antiAfk.enabled and not antiAfk.running then
    antiAfk.running = true
    task.spawn(function()
        while antiAfk.enabled do
            pcall(function() 
                game:GetService("VirtualInputManager"):SendKeyEvent(true, antiAfk.key, false, game) 
            end)
            task.wait(0.06)
            pcall(function() 
                game:GetService("VirtualInputManager"):SendKeyEvent(false, antiAfk.key, false, game) 
            end)
            task.wait(antiAfk.interval + math.random(-2,2))
        end
        antiAfk.running = false
        pcall(function() game:GetService("ContextActionService"):UnbindAction(antiAfk.bindName) end)
    end)
end

-- GUI (inline everything)
SettingsTab:CreateToggle({
    Name = "Enable Anti-AFK",
    CurrentValue = true,
    Flag = "EnableAntiAFK",
    Callback = function(v)
        antiAfk.enabled = v
        if v and not antiAfk.running then
            antiAfk.running = true
            pcall(function() game:GetService("ContextActionService"):UnbindAction(antiAfk.bindName) end)
            game:GetService("ContextActionService"):BindAction(antiAfk.bindName, function() return Enum.ContextActionResult.Sink end, false, antiAfk.key)
            task.spawn(function()
                while antiAfk.enabled do
                    pcall(function() game:GetService("VirtualInputManager"):SendKeyEvent(true, antiAfk.key, false, game) end)
                    task.wait(0.06)
                    pcall(function() game:GetService("VirtualInputManager"):SendKeyEvent(false, antiAfk.key, false, game) end)
                    task.wait(antiAfk.interval + math.random(-2,2))
                end
                antiAfk.running = false
                pcall(function() game:GetService("ContextActionService"):UnbindAction(antiAfk.bindName) end)
            end)
        end
    end,
})

SettingsTab:CreateSlider({
    Name = "AFK Interval (sec)",
    Range = {30, 180},
    Increment = 5,
    CurrentValue = 60,
    Flag = "AntiAFK_Interval",
    Callback = function(v)
        antiAfk.interval = math.max(10, v)
    end,
})
